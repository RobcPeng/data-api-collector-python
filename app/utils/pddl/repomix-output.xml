This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
main.py
pddl_classes.py
pddl_client.py
task_builder.py
task_execution_manager.py
task_repository.py
test_demo.py
workflow_builder.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="main.py">
import json
import subprocess
import tempfile
import os
import re
import uuid
import ipaddress
import xml.etree.ElementTree as ET
from typing import Dict, List, Optional, Any, Tuple, Set, Union
from abc import ABC, abstractmethod
from pydantic import BaseModel, Field
from pathlib import Path
import yaml
from faker import Faker
from email_validator import validate_email, EmailNotValidError

# Import your existing classes and client
from .pddl_classes import *
from .pddl_client import ModelClient, NaturalLanguageParser, PlanExplainer

# Centralized status transition definitions - SINGLE SOURCE OF TRUTH
VALID_STATUS_TRANSITIONS = {
    TaskStatus.PENDING: [TaskStatus.READY, TaskStatus.CANCELLED, TaskStatus.QUEUED, TaskStatus.SCHEDULED],
    TaskStatus.QUEUED: [TaskStatus.READY, TaskStatus.CANCELLED],
    TaskStatus.SCHEDULED: [TaskStatus.READY, TaskStatus.CANCELLED],
    TaskStatus.READY: [TaskStatus.IN_PROGRESS, TaskStatus.BLOCKED, TaskStatus.CANCELLED, TaskStatus.RUNNING, TaskStatus.PROCESSING, TaskStatus.EXECUTING],
    TaskStatus.IN_PROGRESS: [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.PAUSED, TaskStatus.BLOCKED, TaskStatus.SUCCESS, TaskStatus.FINISHED],
    TaskStatus.RUNNING: [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.PAUSED, TaskStatus.SUCCESS, TaskStatus.FINISHED],
    TaskStatus.PROCESSING: [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.PAUSED, TaskStatus.SUCCESS, TaskStatus.FINISHED],
    TaskStatus.EXECUTING: [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.PAUSED, TaskStatus.SUCCESS, TaskStatus.FINISHED],
    TaskStatus.BLOCKED: [TaskStatus.READY, TaskStatus.CANCELLED, TaskStatus.WAITING],
    TaskStatus.WAITING: [TaskStatus.READY, TaskStatus.CANCELLED],
    TaskStatus.PAUSED: [TaskStatus.IN_PROGRESS, TaskStatus.CANCELLED, TaskStatus.RUNNING],
    TaskStatus.SUSPENDED: [TaskStatus.READY, TaskStatus.CANCELLED],
    TaskStatus.ON_HOLD: [TaskStatus.READY, TaskStatus.CANCELLED],
    TaskStatus.UNDER_REVIEW: [TaskStatus.APPROVED, TaskStatus.REJECTED],
    TaskStatus.APPROVED: [TaskStatus.READY, TaskStatus.IN_PROGRESS],
    TaskStatus.REJECTED: [TaskStatus.CANCELLED, TaskStatus.PENDING],
    TaskStatus.RETRYING: [TaskStatus.IN_PROGRESS, TaskStatus.FAILED, TaskStatus.RUNNING],
    TaskStatus.RETRY_PENDING: [TaskStatus.RETRYING, TaskStatus.CANCELLED],
    TaskStatus.TIMEOUT: [TaskStatus.RETRYING, TaskStatus.FAILED, TaskStatus.CANCELLED],
    TaskStatus.ABORTED: [TaskStatus.PENDING, TaskStatus.CANCELLED],
    # Terminal states
    TaskStatus.COMPLETED: [],
    TaskStatus.SUCCESS: [],
    TaskStatus.FINISHED: [],
    TaskStatus.FAILED: [TaskStatus.RETRYING, TaskStatus.RETRY_PENDING],
    TaskStatus.ERROR: [TaskStatus.RETRYING, TaskStatus.RETRY_PENDING],
    TaskStatus.CANCELLED: [],
}

class SecurityError(Exception):
    """Exception for security-related errors"""
    pass

class ValidationError(Exception):
    """Exception for validation errors"""
    pass

class PlanningError(Exception):
    """Exception for planning-related errors"""
    pass

class ContractValidator:
    """Validates that tasks follow their contracts with robust validation"""
    
    def __init__(self):
        self.faker = Faker()
        self._type_validators = self._build_type_validators()
        self._rule_validators = self._build_rule_validators()
    
    def _build_type_validators(self) -> Dict[DataType, callable]:
        """Build robust type validators"""
        return {
            # Primitive types
            DataType.STRING: lambda v: isinstance(v, str),
            DataType.INTEGER: lambda v: isinstance(v, int),
            DataType.FLOAT: lambda v: isinstance(v, float),
            DataType.DECIMAL: lambda v: isinstance(v, (int, float)),
            DataType.BOOLEAN: lambda v: isinstance(v, bool),
            DataType.NULL: lambda v: v is None,
            
            # Date and time types
            DataType.DATE: self._validate_date_format,
            DataType.TIME: self._validate_time_format,
            DataType.DATE_TIME: self._validate_datetime_format,
            DataType.TIMESTAMP: lambda v: isinstance(v, (int, float)) and v > 0,
            DataType.TIMEZONE: self._validate_timezone,
            DataType.DURATION: lambda v: isinstance(v, (int, float)) and v >= 0,
            
            # Structured data types
            DataType.JSON: lambda v: isinstance(v, (dict, list)),
            DataType.XML: self._validate_xml,
            DataType.YAML: self._validate_yaml,
            DataType.CSV: self._validate_csv,
            DataType.ARRAY: lambda v: isinstance(v, list),
            DataType.LIST: lambda v: isinstance(v, list),
            DataType.DICTIONARY: lambda v: isinstance(v, dict),
            DataType.OBJECT: lambda v: isinstance(v, dict),
            
            # File types
            DataType.FILE: lambda v: isinstance(v, str) and Path(v).exists(),
            DataType.BINARY: lambda v: isinstance(v, bytes),
            DataType.TEXT_FILE: self._validate_text_file,
            DataType.IMAGE: self._validate_image_file,
            DataType.VIDEO: self._validate_video_file,
            DataType.AUDIO: self._validate_audio_file,
            DataType.DOCUMENT: lambda v: isinstance(v, str) and Path(v).exists(),
            
            # Document formats
            DataType.PDF: lambda v: isinstance(v, str) and v.lower().endswith('.pdf'),
            DataType.WORD_DOC: lambda v: isinstance(v, str) and v.lower().endswith(('.doc', '.docx')),
            DataType.EXCEL: lambda v: isinstance(v, str) and v.lower().endswith(('.xls', '.xlsx')),
            DataType.POWERPOINT: lambda v: isinstance(v, str) and v.lower().endswith(('.ppt', '.pptx')),
            DataType.HTML: self._validate_html,
            DataType.MARKDOWN: self._validate_markdown,
            
            # Network and web types
            DataType.URL: self._validate_url,
            DataType.EMAIL: self._validate_email,
            DataType.IP_ADDRESS: self._validate_ip_address,
            DataType.MAC_ADDRESS: self._validate_mac_address,
            DataType.UUID: self._validate_uuid,
            
            # Database types
            DataType.DATABASE_RECORD: lambda v: isinstance(v, dict) and 'id' in v,
            DataType.PRIMARY_KEY: lambda v: isinstance(v, (str, int)) and v,
            DataType.FOREIGN_KEY: lambda v: isinstance(v, (str, int)) and v,
            DataType.BLOB: lambda v: isinstance(v, bytes),
            DataType.CLOB: lambda v: isinstance(v, str),
            
            # Geographic types
            DataType.COORDINATE: self._validate_coordinate,
            DataType.LATITUDE: lambda v: isinstance(v, (int, float)) and -90 <= v <= 90,
            DataType.LONGITUDE: lambda v: isinstance(v, (int, float)) and -180 <= v <= 180,
            DataType.ADDRESS: lambda v: isinstance(v, str) and len(v.strip()) > 5,
            DataType.POSTAL_CODE: lambda v: isinstance(v, str) and v.strip(),
            
            # Financial types
            DataType.CURRENCY: lambda v: isinstance(v, str) and len(v) == 3 and v.isalpha(),
            DataType.PRICE: lambda v: isinstance(v, (int, float)) and v >= 0,
            DataType.PERCENTAGE: lambda v: isinstance(v, (int, float)) and 0 <= v <= 100,
            
            # Security types
            DataType.PASSWORD: self._validate_password,
            DataType.TOKEN: lambda v: isinstance(v, str) and len(v) > 10,
            DataType.API_KEY: lambda v: isinstance(v, str) and len(v) > 10,
            DataType.ENCRYPTED_DATA: lambda v: isinstance(v, str),
            DataType.HASH: lambda v: isinstance(v, str) and len(v) >= 32,
            
            # Communication types
            DataType.PHONE_NUMBER: self._validate_phone_number,
            DataType.MESSAGE: lambda v: isinstance(v, str) and v.strip(),
            DataType.NOTIFICATION: lambda v: isinstance(v, dict) and 'message' in v,
            
            # Measurement types
            DataType.METRIC: lambda v: isinstance(v, (int, float)),
            DataType.UNIT_OF_MEASURE: lambda v: isinstance(v, str),
            DataType.QUANTITY: lambda v: isinstance(v, (int, float)) and v >= 0,
            
            # Custom types
            DataType.REGEX_PATTERN: self._validate_regex_pattern,
            DataType.COLOR_CODE: self._validate_color_code,
            DataType.VERSION_NUMBER: self._validate_version_number,
            DataType.STATUS_CODE: lambda v: isinstance(v, int) and 100 <= v <= 599,
        }
    
    def _build_rule_validators(self) -> Dict[str, callable]:
        """Build rule validators with efficient lookup"""
        return {
            'length >': lambda v, val: len(str(v)) > int(val),
            'length <': lambda v, val: len(str(v)) < int(val),
            'length =': lambda v, val: len(str(v)) == int(val),
            'min': lambda v, val: float(v) >= float(val),
            'max': lambda v, val: float(v) <= float(val),
            'not empty': lambda v, _: bool(v) and str(v).strip(),
            'positive': lambda v, _: isinstance(v, (int, float)) and v > 0,
            'negative': lambda v, _: isinstance(v, (int, float)) and v < 0,
            'non-negative': lambda v, _: isinstance(v, (int, float)) and v >= 0,
            'has': lambda v, field: isinstance(v, dict) and field in v,
            'contains': lambda v, substring: str(substring) in str(v),
            'starts with': lambda v, prefix: str(v).startswith(str(prefix)),
            'ends with': lambda v, suffix: str(v).endswith(str(suffix)),
            'matches': lambda v, pattern: bool(re.match(pattern, str(v))),
            'in range': self._validate_range,
            'unique': lambda v, _: len(v) == len(set(v)) if isinstance(v, list) else True,
            'alphanumeric': lambda v, _: str(v).isalnum(),
            'alphabetic': lambda v, _: str(v).isalpha(),
            'numeric': lambda v, _: str(v).isnumeric(),
        }
    
    def validate_task_inputs(self, task: Task, inputs: Dict[str, Any]) -> List[str]:
        """Validate inputs with specific exception handling"""
        errors = []
        
        for input_contract in task.contract.inputs:
            try:
                if input_contract.required and input_contract.name not in inputs:
                    errors.append(f"Required input '{input_contract.name}' missing for task {task.id}")
                    continue
                
                if input_contract.name in inputs:
                    value = inputs[input_contract.name]
                    
                    if not self._validate_data_type(value, input_contract.data_type):
                        errors.append(f"Input '{input_contract.name}' has wrong type. Expected {input_contract.data_type.value}, got {type(value).__name__}")
                    
                    for rule in input_contract.validation_rules:
                        if not self._validate_rule(value, rule):
                            errors.append(f"Input '{input_contract.name}' failed validation rule: {rule}")
            
            except (ValueError, TypeError) as e:
                errors.append(f"Validation error for input '{input_contract.name}': {str(e)}")
        
        return errors
    
    def validate_task_outputs(self, task: Task, outputs: Dict[str, Any]) -> List[str]:
        """Validate outputs with specific exception handling"""
        errors = []
        
        for output_contract in task.contract.outputs:
            try:
                if output_contract.name not in outputs:
                    errors.append(f"Required output '{output_contract.name}' missing for task {task.id}")
                    continue
                
                value = outputs[output_contract.name]
                
                if not self._validate_data_type(value, output_contract.data_type):
                    errors.append(f"Output '{output_contract.name}' has wrong type. Expected {output_contract.data_type.value}, got {type(value).__name__}")
                
                for rule in output_contract.validation_rules:
                    if not self._validate_rule(value, rule):
                        errors.append(f"Output '{output_contract.name}' failed validation rule: {rule}")
            
            except (ValueError, TypeError) as e:
                errors.append(f"Validation error for output '{output_contract.name}': {str(e)}")
        
        return errors
    
    def _validate_data_type(self, value: Any, expected_type: DataType) -> bool:
        """Validate data type with specific exception handling"""
        validator_func = self._type_validators.get(expected_type)
        if validator_func:
            try:
                return validator_func(value)
            except (ValueError, TypeError, AttributeError):
                return False
        return True
    
    def _validate_rule(self, value: Any, rule: str) -> bool:
        """Efficiently validate rules with direct lookup"""
        try:
            # Parse rule format efficiently
            for rule_key, validator_func in self._rule_validators.items():
                if rule.startswith(rule_key):
                    param = rule.replace(rule_key, '').strip()
                    return validator_func(value, param)
            return True
        except (ValueError, TypeError, AttributeError):
            return False
    
    # Robust validation helper methods
    def _validate_email(self, value: str) -> bool:
        """Robust email validation using email_validator"""
        try:
            validate_email(str(value))
            return True
        except EmailNotValidError:
            return False
    
    def _validate_url(self, value: str) -> bool:
        """Robust URL validation"""
        url_pattern = re.compile(
            r'^https?://'  # http:// or https://
            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain...
            r'localhost|'  # localhost...
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
            r'(?::\d+)?'  # optional port
            r'(?:/?|[/?]\S+)$', re.IGNORECASE)
        return bool(url_pattern.match(str(value)))
    
    def _validate_ip_address(self, value: str) -> bool:
        """Validate IP address using ipaddress module"""
        try:
            ipaddress.ip_address(str(value))
            return True
        except ValueError:
            return False
    
    def _validate_mac_address(self, value: str) -> bool:
        """Validate MAC address with proper regex"""
        pattern = r'^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$'
        return bool(re.match(pattern, str(value)))
    
    def _validate_uuid(self, value: str) -> bool:
        """Validate UUID format"""
        try:
            uuid.UUID(str(value))
            return True
        except ValueError:
            return False
    
    def _validate_xml(self, value: str) -> bool:
        """Validate XML format"""
        try:
            ET.fromstring(str(value))
            return True
        except ET.ParseError:
            return False
    
    def _validate_yaml(self, value: str) -> bool:
        """Validate YAML format"""
        try:
            yaml.safe_load(str(value))
            return True
        except yaml.YAMLError:
            return False
    
    def _validate_csv(self, value: str) -> bool:
        """Basic CSV validation"""
        return isinstance(value, str) and '\n' in value and ',' in value
    
    def _validate_html(self, value: str) -> bool:
        """Basic HTML validation"""
        return isinstance(value, str) and ('<html>' in value.lower() or value.endswith('.html'))
    
    def _validate_markdown(self, value: str) -> bool:
        """Basic Markdown validation"""
        return isinstance(value, str) and (value.endswith('.md') or '#' in value or '*' in value)
    
    def _validate_date_format(self, value: str) -> bool:
        """Validate date format"""
        try:
            from datetime import datetime
            datetime.strptime(str(value), '%Y-%m-%d')
            return True
        except ValueError:
            return False
    
    def _validate_time_format(self, value: str) -> bool:
        """Validate time format"""
        try:
            from datetime import datetime
            datetime.strptime(str(value), '%H:%M:%S')
            return True
        except ValueError:
            return False
    
    def _validate_datetime_format(self, value: str) -> bool:
        """Validate datetime format"""
        try:
            from datetime import datetime
            datetime.fromisoformat(str(value).replace('Z', '+00:00'))
            return True
        except ValueError:
            return False
    
    def _validate_timezone(self, value: str) -> bool:
        """Validate timezone string"""
        common_timezones = {'UTC', 'GMT', 'EST', 'PST', 'CST', 'MST'}
        return str(value) in common_timezones or '+' in str(value) or '-' in str(value)
    
    def _validate_text_file(self, value: str) -> bool:
        """Validate text file"""
        return isinstance(value, str) and Path(value).exists() and value.endswith(('.txt', '.md'))
    
    def _validate_image_file(self, value: str) -> bool:
        """Validate image file"""
        return isinstance(value, str) and value.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg'))
    
    def _validate_video_file(self, value: str) -> bool:
        """Validate video file"""
        return isinstance(value, str) and value.lower().endswith(('.mp4', '.avi', '.mov', '.wmv', '.flv'))
    
    def _validate_audio_file(self, value: str) -> bool:
        """Validate audio file"""
        return isinstance(value, str) and value.lower().endswith(('.mp3', '.wav', '.ogg', '.m4a', '.flac'))
    
    def _validate_coordinate(self, value: Any) -> bool:
        """Validate coordinate pair"""
        return isinstance(value, (list, tuple)) and len(value) == 2 and all(isinstance(x, (int, float)) for x in value)
    
    def _validate_password(self, value: str) -> bool:
        """Validate password strength"""
        return isinstance(value, str) and len(value) >= 8
    
    def _validate_phone_number(self, value: str) -> bool:
        """Validate phone number"""
        cleaned = re.sub(r'[^\d+]', '', str(value))
        return len(cleaned) >= 10 and (cleaned.startswith('+') or cleaned.isdigit())
    
    def _validate_regex_pattern(self, value: str) -> bool:
        """Validate regex pattern"""
        try:
            re.compile(str(value))
            return True
        except re.error:
            return False
    
    def _validate_color_code(self, value: str) -> bool:
        """Validate color code"""
        hex_pattern = r'^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$'
        rgb_pattern = r'^rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$'
        return bool(re.match(hex_pattern, str(value)) or re.match(rgb_pattern, str(value)))
    
    def _validate_version_number(self, value: str) -> bool:
        """Validate semantic version number"""
        pattern = r'^\d+\.\d+\.\d+(-\w+)?$'
        return bool(re.match(pattern, str(value)))
    
    def _validate_range(self, value: Any, range_str: str) -> bool:
        """Validate value is in range"""
        try:
            if '-' in range_str:
                min_val, max_val = map(float, range_str.split('-'))
                return min_val <= float(value) <= max_val
            return True
        except (ValueError, TypeError):
            return False

class PDDLGenerator:
    """PDDL generator using centralized status transitions"""
    
    def generate_domain(self, state: PlanningState) -> str:
        """Generate PDDL domain with centralized transitions"""
        
        # Generate predicates for all TaskStatus values
        status_predicates = []
        for status in TaskStatus:
            predicate_name = status.value.replace('_', '-')
            status_predicates.append(f"    (task-{predicate_name} ?t - task)")
        
        # Generate predicates for all ResourceType values
        resource_predicates = []
        for resource_type in ResourceType:
            predicate_name = resource_type.value.replace('_', '-')
            resource_predicates.append(f"    (is-{predicate_name} ?r - resource)")
            resource_predicates.append(f"    (needs-{predicate_name} ?t - task)")
        
        # Generate actions using centralized transitions
        status_actions = self._generate_status_transition_actions()
        
        domain_pddl = f"""(define (domain dynamic-contract-planning)
  (:requirements :strips :typing :conditional-effects :adl)
  
  (:types
    task resource datatype - object
  )
  
  (:predicates
    ; Dynamic task status predicates
{"\n".join(status_predicates)}
    
    ; Relationship predicates
    (depends-on ?t1 ?t2 - task)
    (requires-resource ?t - task ?r - resource)
    
    ; Dynamic resource type predicates
{"\n".join(resource_predicates)}
    (resource-available ?r - resource)
    (resource-allocated ?r - resource ?t - task)
    
    ; Contract enforcement predicates
    (has-input ?t - task ?input - datatype)
    (has-output ?t - task ?output - datatype)
    (precondition-met ?t - task ?condition - object)
    (postcondition-satisfied ?t - task ?condition - object)
    (contract-valid ?t - task)
    (input-validated ?t - task)
    (output-validated ?t - task)
  )
  
{status_actions}
  
  (:action validate-inputs
    :parameters (?t - task)
    :precondition (and 
      (task-ready ?t)
      (contract-valid ?t)
      (forall (?input - datatype) 
        (imply (has-input ?t ?input) (precondition-met ?t ?input)))
    )
    :effect (input-validated ?t)
  )
  
  (:action validate-outputs
    :parameters (?t - task)
    :precondition (task-in-progress ?t)
    :effect (and
      (output-validated ?t)
      (forall (?output - datatype)
        (when (has-output ?t ?output)
          (postcondition-satisfied ?t ?output)))
    )
  )
  
  (:action allocate-resource
    :parameters (?t - task ?r - resource)
    :precondition (and
      (task-ready ?t)
      (requires-resource ?t ?r)
      (resource-available ?r)
    )
    :effect (and
      (resource-allocated ?r ?t)
      (not (resource-available ?r))
    )
  )
  
  (:action deallocate-resource
    :parameters (?t - task ?r - resource)
    :precondition (resource-allocated ?r ?t)
    :effect (and
      (resource-available ?r)
      (not (resource-allocated ?r ?t))
    )
  )
)"""
        return domain_pddl
    
    def _generate_status_transition_actions(self) -> str:
        """Generate PDDL actions using centralized transitions"""
        actions = []
        
        for from_status, to_statuses in VALID_STATUS_TRANSITIONS.items():
            for to_status in to_statuses:
                action_block = self._create_transition_action(from_status, to_status)
                actions.append(action_block)
        
        return '\n'.join(actions)
    
    def _create_transition_action(self, from_status: TaskStatus, to_status: TaskStatus) -> str:
        """Helper to create individual transition action"""
        from_pred = from_status.value.replace('_', '-')
        to_pred = to_status.value.replace('_', '-')
        
        return f"""  (:action transition-{from_pred}-to-{to_pred}
    :parameters (?t - task)
    :precondition (task-{from_pred} ?t)
    :effect (and 
      (task-{to_pred} ?t)
      (not (task-{from_pred} ?t))
    )
  )"""
    
    def generate_problem(self, state: PlanningState, goal_tasks: List[str] = None) -> str:
        """Generate PDDL problem file"""
        
        if goal_tasks is None:
            goal_tasks = list(state.tasks.keys())
        
        # Generate objects
        task_objects = " ".join([f"{tid} - task" for tid in state.tasks.keys()])
        resource_objects = " ".join([f"{rid} - resource" for rid in state.resources.keys()])
        
        all_datatypes = set()
        for task in state.tasks.values():
            for inp in task.contract.inputs:
                all_datatypes.add(inp.name.replace(' ', '_').lower())
            for out in task.contract.outputs:
                all_datatypes.add(out.name.replace(' ', '_').lower())
        
        datatype_objects = " ".join([f"{dt} - datatype" for dt in all_datatypes])
        
        # Generate initial state
        init_predicates = self._generate_initial_predicates(state)
        
        # Goal state with multiple completion options
        completion_statuses = [TaskStatus.COMPLETED, TaskStatus.SUCCESS, TaskStatus.FINISHED]
        goal_predicates = []
        for task_id in goal_tasks:
            completion_options = [f"(task-{status.value.replace('_', '-')} {task_id})" 
                                for status in completion_statuses]
            if len(completion_options) > 1:
                goal_predicates.append(f"(or {' '.join(completion_options)})")
            else:
                goal_predicates.extend(completion_options)
        
        problem_pddl = f"""(define (problem dynamic-contract-plan)
  (:domain dynamic-contract-planning)
  
  (:objects
    {task_objects}
    {resource_objects}
    {datatype_objects}
  )
  
  (:init
    {"\n".join(f"    {pred}" for pred in init_predicates)}
  )
  
  (:goal
    (and {' '.join(goal_predicates)})
  )
)"""
        return problem_pddl
    
    def _generate_initial_predicates(self, state: PlanningState) -> List[str]:
        """Generate initial state predicates"""
        init_predicates = []
        
        # Task states
        for task_id, task in state.tasks.items():
            status_pred = task.status.value.replace('_', '-')
            init_predicates.append(f"(task-{status_pred} {task_id})")
        
        # Dependencies
        for task_id, task in state.tasks.items():
            for dep_id in task.dependencies:
                init_predicates.append(f"(depends-on {task_id} {dep_id})")
        
        # Resource requirements and types
        for task_id, task in state.tasks.items():
            for resource_id in task.required_resources:
                init_predicates.append(f"(requires-resource {task_id} {resource_id})")
                
                if resource_id in state.resources:
                    resource = state.resources[resource_id]
                    resource_type_pred = resource.resource_type.value.replace('_', '-')
                    init_predicates.append(f"(is-{resource_type_pred} {resource_id})")
                    init_predicates.append(f"(needs-{resource_type_pred} {task_id})")
        
        # Contract predicates
        for task_id, task in state.tasks.items():
            for inp in task.contract.inputs:
                input_name = inp.name.replace(' ', '_').lower()
                init_predicates.append(f"(has-input {task_id} {input_name})")
            for out in task.contract.outputs:
                output_name = out.name.replace(' ', '_').lower()
                init_predicates.append(f"(has-output {task_id} {output_name})")
            init_predicates.append(f"(contract-valid {task_id})")
        
        # Resource availability
        for resource_id in state.available_resources:
            init_predicates.append(f"(resource-available {resource_id})")
        
        return init_predicates

class ResourceManager:
    """Consolidated resource manager using data-driven approach"""
    
    def __init__(self):
        self.resource_handlers = {
            # Human resources
            ResourceType.DEVELOPER: "Developer",
            ResourceType.QA: "QA Engineer", 
            ResourceType.DESIGNER: "Designer",
            ResourceType.PRODUCT_MANAGER: "Product Manager",
            ResourceType.DEVOPS_ENGINEER: "DevOps Engineer",
            ResourceType.DATA_SCIENTIST: "Data Scientist",
            ResourceType.SECURITY_ANALYST: "Security Analyst",
            ResourceType.BUSINESS_ANALYST: "Business Analyst",
            
            # Infrastructure resources
            ResourceType.DATABASE: "Database",
            ResourceType.CACHE: "Cache",
            ResourceType.MESSAGE_QUEUE: "Message Queue",
            ResourceType.LOAD_BALANCER: "Load Balancer",
            ResourceType.CDN: "CDN",
            ResourceType.STORAGE: "Storage",
            ResourceType.BACKUP: "Backup",
            
            # Compute resources
            ResourceType.COMPUTE: "Compute",
            ResourceType.CPU: "CPU",
            ResourceType.GPU: "GPU", 
            ResourceType.MEMORY: "Memory",
            ResourceType.CONTAINER: "Container",
            ResourceType.VIRTUAL_MACHINE: "Virtual Machine",
            ResourceType.SERVERLESS_FUNCTION: "Serverless Function",
            
            # Network resources
            ResourceType.NETWORK: "Network",
            ResourceType.BANDWIDTH: "Bandwidth",
            ResourceType.VPN: "VPN",
            ResourceType.FIREWALL: "Firewall",
            ResourceType.DNS: "DNS",
        }
    
    def allocate_resource(self, resource: Resource, context: ExecutionContext) -> bool:
        """Allocate resource using data-driven approach"""
        resource_name = self.resource_handlers.get(resource.resource_type, "Unknown Resource")
        
        try:
            context.execution_trace.append(f"Allocating {resource_name}: {resource.name}")
            
            # Resource-specific allocation logic could go here
            if resource.resource_type in [ResourceType.DATABASE, ResourceType.CACHE]:
                return self._allocate_data_resource(resource, context)
            elif resource.resource_type in [ResourceType.COMPUTE, ResourceType.CPU, ResourceType.GPU, ResourceType.MEMORY]:
                return self._allocate_compute_resource(resource, context) 
            else:
                return self._allocate_generic_resource(resource, context)
                
        except Exception as e:
            context.errors.append(f"Failed to allocate {resource_name} {resource.name}: {str(e)}")
            return False
    
    def deallocate_resource(self, resource: Resource, context: ExecutionContext) -> bool:
        """Deallocate resource"""
        resource_name = self.resource_handlers.get(resource.resource_type, "Unknown Resource")
        
        try:
            context.execution_trace.append(f"Deallocating {resource_name}: {resource.name}")
            
            # Resource-specific deallocation logic
            if resource.resource_type in [ResourceType.DATABASE, ResourceType.CACHE]:
                return self._deallocate_data_resource(resource, context)
            elif resource.resource_type in [ResourceType.COMPUTE, ResourceType.CPU, ResourceType.GPU, ResourceType.MEMORY]:
                return self._deallocate_compute_resource(resource, context)
            else:
                return self._deallocate_generic_resource(resource, context)
                
        except Exception as e:
            context.errors.append(f"Failed to deallocate {resource_name} {resource.name}: {str(e)}")
            return False
    
    def _allocate_data_resource(self, resource: Resource, context: ExecutionContext) -> bool:
        """Allocate data-related resources"""
        # Simulate database connection, cache setup, etc.
        context.execution_trace.append(f"Establishing connection to {resource.name}")
        return True
    
    def _deallocate_data_resource(self, resource: Resource, context: ExecutionContext) -> bool:
        """Deallocate data-related resources"""
        context.execution_trace.append(f"Closing connection to {resource.name}")
        return True
    
    def _allocate_compute_resource(self, resource: Resource, context: ExecutionContext) -> bool:
        """Allocate compute resources"""
        context.execution_trace.append(f"Reserving {resource.name} compute capacity")
        return True
    
    def _deallocate_compute_resource(self, resource: Resource, context: ExecutionContext) -> bool:
        """Deallocate compute resources"""
        context.execution_trace.append(f"Releasing {resource.name} compute capacity")
        return True
    
    def _allocate_generic_resource(self, resource: Resource, context: ExecutionContext) -> bool:
        """Generic resource allocation"""
        return True
    
    def _deallocate_generic_resource(self, resource: Resource, context: ExecutionContext) -> bool:
        """Generic resource deallocation"""
        return True

class ActualPDDLPlanner:
    """Real PDDL planner that uses external solvers"""
    
    def __init__(self, model: str = "codestral:latest", solver_path: str = "fast-downward"):
        self.model_client = ModelClient(model)
        self.parser = NaturalLanguageParser(self.model_client)
        self.explainer = PlanExplainer(self.model_client)
        self.pddl_generator = PDDLGenerator()
        self.contract_validator = ContractValidator()
        self.resource_manager = ResourceManager()
        self.solver_path = solver_path
        
        # Build enum alias dictionaries once for efficiency
        self._data_type_aliases = self._build_data_type_aliases()
        self._task_status_aliases = self._build_task_status_aliases()
        self._resource_type_aliases = self._build_resource_type_aliases()
    
    def _build_data_type_aliases(self) -> Dict[str, DataType]:
        """Build data type aliases once for efficient lookup"""
        aliases = {}
        
        # Direct mappings
        for dt in DataType:
            normalized = dt.value.upper().replace(' ', '_').replace('-', '_')
            aliases[normalized] = dt
        
        # Common aliases
        common_aliases = {
            'STR': DataType.STRING,
            'INT': DataType.INTEGER,
            'BOOL': DataType.BOOLEAN,
            'DATETIME': DataType.DATE_TIME,
            'TIMESTAMP': DataType.DATE_TIME,
            'FLOAT': DataType.FLOAT,
            'DECIMAL': DataType.DECIMAL,
            'ARRAY': DataType.ARRAY,
            'LIST': DataType.LIST,
            'DICT': DataType.DICTIONARY,
            'OBJECT': DataType.OBJECT,
        }
        aliases.update(common_aliases)
        
        return aliases
    
    def _build_task_status_aliases(self) -> Dict[str, TaskStatus]:
        """Build task status aliases once"""
        aliases = {}
        
        for status in TaskStatus:
            normalized = status.value.upper().replace(' ', '_').replace('-', '_')
            aliases[normalized] = status
        
        common_aliases = {
            'NEW': TaskStatus.PENDING,
            'CREATED': TaskStatus.PENDING,
            'STARTED': TaskStatus.IN_PROGRESS,
            'ACTIVE': TaskStatus.IN_PROGRESS,
            'DONE': TaskStatus.COMPLETED,
            'FINISHED': TaskStatus.COMPLETED,
            'COMPLETE': TaskStatus.COMPLETED,
            'STOPPED': TaskStatus.PAUSED,
            'HALTED': TaskStatus.PAUSED,
            'WAITING_FOR_DEPS': TaskStatus.BLOCKED,
            'WAITING_FOR_RESOURCES': TaskStatus.BLOCKED,
        }
        aliases.update(common_aliases)
        
        return aliases
    
    def _build_resource_type_aliases(self) -> Dict[str, ResourceType]:
        """Build resource type aliases once"""
        aliases = {}
        
        for rt in ResourceType:
            normalized = rt.value.upper().replace(' ', '_').replace('-', '_')
            aliases[normalized] = rt
        
        common_aliases = {
            'DEV': ResourceType.DEVELOPER,
            'PROGRAMMER': ResourceType.DEVELOPER,
            'CODER': ResourceType.DEVELOPER,
            'TESTER': ResourceType.QA,
            'QUALITY_ASSURANCE': ResourceType.QA,
            'DB': ResourceType.DATABASE,
            'API': ResourceType.API_ENDPOINT,
            'ENDPOINT': ResourceType.API_ENDPOINT,
            'FILESYSTEM': ResourceType.FILE_SYSTEM,
            'FS': ResourceType.FILE_SYSTEM,
            'CPU': ResourceType.CPU,
            'PROCESSOR': ResourceType.CPU,
            'RAM': ResourceType.MEMORY,
            'MEMORY': ResourceType.MEMORY,
            'NET': ResourceType.NETWORK,
            'NETWORKING': ResourceType.NETWORK,
        }
        aliases.update(common_aliases)
        
        return aliases
    
    def parse_natural_language_request(self, user_request: str) -> PlanningState:
        """Parse natural language with optimized enum lookups"""
        parsed_data = self.parser.parse_requirements_to_tasks(user_request)
        return self._create_planning_state_from_parsed_data(parsed_data)
    
    def _create_planning_state_from_parsed_data(self, parsed_data: dict) -> PlanningState:
        """Create planning state with optimized enum parsing"""
        
        tasks = {}
        for task_data in parsed_data.get("tasks", []):
            contract_data = task_data.get("contract", {})
            
            # Parse contract inputs/outputs with optimized lookups
            inputs = []
            for inp in contract_data.get("inputs", []):
                data_type = self._parse_data_type_optimized(inp.get("data_type", "string"))
                input_contract = InputContract(
                    name=inp["name"],
                    data_type=data_type,
                    required=inp.get("required", True),
                    validation_rules=inp.get("validation_rules", [])
                )
                inputs.append(input_contract)
            
            outputs = []
            for out in contract_data.get("outputs", []):
                data_type = self._parse_data_type_optimized(out.get("data_type", "string"))
                output_contract = OutputContract(
                    name=out["name"],
                    data_type=data_type,
                    validation_rules=out.get("validation_rules", [])
                )
                outputs.append(output_contract)
            
            contract = TaskContract(
                task_id=task_data["id"],
                inputs=inputs,
                outputs=outputs,
                preconditions=contract_data.get("preconditions", []),
                postconditions=contract_data.get("postconditions", []),
                side_effects=contract_data.get("side_effects", [])
            )
            
            task_status = self._parse_task_status_optimized(task_data.get("status", "pending"))
            
            task = Task(
                id=task_data["id"],
                name=task_data["name"],
                description=task_data["description"],
                duration_hours=task_data.get("duration_hours", 1),
                dependencies=task_data.get("dependencies", []),
                required_resources=task_data.get("required_resources", []),
                contract=contract,
                status=task_status,
                execution_environment=task_data.get("execution_environment", "python")
            )
            tasks[task.id] = task
        
        resources = {}
        for resource_data in parsed_data.get("resources", []):
            resource_type = self._parse_resource_type_optimized(resource_data.get("resource_type", "compute"))
            
            resource = Resource(
                id=resource_data["id"],
                name=resource_data["name"],
                resource_type=resource_type,
                available=resource_data.get("available", True),
                capacity=resource_data.get("capacity", 1),
                properties=resource_data.get("properties", {})
            )
            resources[resource.id] = resource
        
        return PlanningState(
            tasks=tasks,
            resources=resources,
            completed_tasks=parsed_data.get("completed_tasks", [])
        )
    
    def _parse_data_type_optimized(self, data_type_str: str) -> DataType:
        """Optimized data type parsing using pre-built aliases"""
        normalized = data_type_str.upper().replace(' ', '_').replace('-', '_')
        return self._data_type_aliases.get(normalized, DataType.STRING)
    
    def _parse_task_status_optimized(self, status_str: str) -> TaskStatus:
        """Optimized task status parsing"""
        normalized = status_str.upper().replace(' ', '_').replace('-', '_')
        return self._task_status_aliases.get(normalized, TaskStatus.PENDING)
    
    def _parse_resource_type_optimized(self, resource_type_str: str) -> ResourceType:
        """Optimized resource type parsing"""
        normalized = resource_type_str.upper().replace(' ', '_').replace('-', '_')
        return self._resource_type_aliases.get(normalized, ResourceType.COMPUTE)
    
    def plan_with_real_solver(self, state: PlanningState, goal_tasks: List[str] = None) -> Tuple[List[Dict], Dict[str, str]]:
        """Generate plan using actual PDDL solver"""
        
        # Generate PDDL files
        domain_pddl = self.pddl_generator.generate_domain(state)
        problem_pddl = self.pddl_generator.generate_problem(state, goal_tasks)
        
        # Write to temporary files
        with tempfile.TemporaryDirectory() as temp_dir:
            domain_file = Path(temp_dir) / "domain.pddl"
            problem_file = Path(temp_dir) / "problem.pddl"
            plan_file = Path(temp_dir) / "plan.txt"
            
            domain_file.write_text(domain_pddl)
            problem_file.write_text(problem_pddl)
            
            try:
                # Call PDDL solver
                result = subprocess.run([
                    self.solver_path,
                    str(domain_file),
                    str(problem_file),
                    "--plan-file", str(plan_file)
                ], capture_output=True, text=True, timeout=60)
                
                if result.returncode != 0:
                    raise PlanningError(f"PDDL solver failed: {result.stderr}")
                
                # Parse plan output
                if plan_file.exists():
                    plan_actions = self._parse_pddl_plan(plan_file.read_text())
                else:
                    raise PlanningError("No plan file generated by solver")
                
            except subprocess.TimeoutExpired:
                raise PlanningError("PDDL solver timed out")
            except FileNotFoundError:
                raise PlanningError(f"PDDL solver not found at {self.solver_path}")
        
        # Generate code for tasks
        generated_code = {}
        for task_id, task in state.tasks.items():
            if goal_tasks is None or task_id in goal_tasks:
                code = self.model_client.generate_code_with_contract(task)
                generated_code[task_id] = code
                task.generated_code = code
        
        return plan_actions, generated_code
    
    def _parse_pddl_plan(self, plan_text: str) -> List[Dict]:
        """Parse PDDL plan output into structured format"""
        plan_actions = []
        
        for line in plan_text.strip().split('\n'):
            if line.startswith('(') and line.endswith(')'):
                # Parse action: (action-name param1 param2 ...)
                action_parts = line[1:-1].split()
                if action_parts:
                    action_name = action_parts[0]
                    parameters = action_parts[1:] if len(action_parts) > 1 else []
                    
                    plan_actions.append({
                        "action": action_name,
                        "parameters": parameters,
                        "raw": line
                    })
        
        return plan_actions
    
    def plan_with_topological_sort(self, state: PlanningState, goal_tasks: List[str] = None) -> List[Dict]:
        """Simplified planning using topological sort"""
        if goal_tasks is None:
            goal_tasks = list(state.tasks.keys())
        
        plan = []
        working_state = PlanningState(**state.model_dump())
        completion_statuses = {TaskStatus.COMPLETED, TaskStatus.SUCCESS, TaskStatus.FINISHED}
        
        # Build dependency graph
        in_degree = {task_id: 0 for task_id in goal_tasks}
        dependents = {task_id: [] for task_id in goal_tasks}
        
        for task_id in goal_tasks:
            task = working_state.tasks[task_id]
            for dep_id in task.dependencies:
                if dep_id in goal_tasks:
                    in_degree[task_id] += 1
                    dependents[dep_id].append(task_id)
        
        # Find ready tasks (in-degree of 0)
        ready_queue = [task_id for task_id, degree in in_degree.items() if degree == 0]
        
        while ready_queue:
            task_id = ready_queue.pop(0)
            task = working_state.tasks[task_id]
            
            # Execute task
            plan.append({
                "action": "execute_task",
                "task_id": task_id,
                "task_name": task.name,
                "duration": task.duration_hours,
                "start_time": working_state.current_time,
                "end_time": working_state.current_time + task.duration_hours,
                "resources_used": task.required_resources
            })
            
            # Mark as completed
            task.status = TaskStatus.COMPLETED
            working_state.completed_tasks.append(task_id)
            working_state.current_time += task.duration_hours
            
            # Update dependents
            for dependent_id in dependents[task_id]:
                in_degree[dependent_id] -= 1
                if in_degree[dependent_id] == 0:
                    ready_queue.append(dependent_id)
        
        return plan

def validate_status_transition(from_status: TaskStatus, to_status: TaskStatus) -> bool:
    """Validate status transition using centralized definitions"""
    allowed_transitions = VALID_STATUS_TRANSITIONS.get(from_status, [])
    return to_status in allowed_transitions

class PlanRequest(BaseModel):
    description: str
    requirements: List[str] = Field(default_factory=list)
    team_resources: List[str] = Field(default_factory=list)
    enforce_contracts: bool = True
    preferred_execution_environment: str = "python"
    use_real_pddl_solver: bool = False
    solver_timeout: int = 60

class PlanResponse(BaseModel):
    plan: List[Dict[str, Any]]
    generated_code: Dict[str, str]
    contracts: Dict[str, TaskContract]
    validation_results: Dict[str, List[str]]
    execution_ready: bool
    resource_allocation: Dict[str, List[str]]
    status_transitions: List[Dict[str, str]]
    solver_used: str

class SecureContractPlanningAPI:
    """Secure planning API with proper error handling and real PDDL support"""
    
    def __init__(self, model: str = "codestral:latest", solver_path: str = "fast-downward"):
        self.planner = ActualPDDLPlanner(model, solver_path)
        self.faker = Faker()
    
    def create_plan(self, request: PlanRequest) -> PlanResponse:
        """Create plan with secure execution and proper error handling"""
        
        try:
            # Parse requirements with optimized enum handling
            state = self.planner.parse_natural_language_request(request.description)
            
            # Set execution environment
            for task in state.tasks.values():
                if not hasattr(task, 'execution_environment') or not task.execution_environment:
                    task.execution_environment = request.preferred_execution_environment
            
            # Choose planning method
            if request.use_real_pddl_solver:
                try:
                    plan, generated_code = self.planner.plan_with_real_solver(state)
                    solver_used = "PDDL Solver"
                except (PlanningError, subprocess.SubprocessError) as e:
                    # Fallback to topological sort
                    plan = self.planner.plan_with_topological_sort(state)
                    generated_code = self._generate_code_for_tasks(state)
                    solver_used = f"Topological Sort (PDDL solver failed: {str(e)})"
            else:
                plan = self.planner.plan_with_topological_sort(state)
                generated_code = self._generate_code_for_tasks(state)
                solver_used = "Topological Sort"
            
            # Extract planning data
            contracts = {tid: task.contract for tid, task in state.tasks.items()}
            resource_allocation = {tid: task.required_resources for tid, task in state.tasks.items()}
            
            # Track status transitions
            status_transitions = []
            for action in plan:
                if "status_transition" in action:
                    status_transitions.append({
                        "task_id": action["task_id"],
                        "transition": action["status_transition"],
                        "time": action.get("time", 0)
                    })
            
            # Validate contracts with realistic sample data
            validation_results = {}
            for task_id, task in state.tasks.items():
                sample_inputs = self._generate_realistic_sample_inputs(task.contract)
                input_errors = self.planner.contract_validator.validate_task_inputs(task, sample_inputs)
                validation_results[task_id] = input_errors
            
            execution_ready = all(not errors for errors in validation_results.values())
            
            return PlanResponse(
                plan=plan,
                generated_code=generated_code,
                contracts=contracts,
                validation_results=validation_results,
                execution_ready=execution_ready,
                resource_allocation=resource_allocation,
                status_transitions=status_transitions,
                solver_used=solver_used
            )
            
        except ValidationError as e:
            raise e
        except SecurityError as e:
            raise e
        except Exception as e:
            raise PlanningError(f"Planning failed: {str(e)}") from e
    
    def _generate_code_for_tasks(self, state: PlanningState) -> Dict[str, str]:
        """Generate code for all tasks"""
        generated_code = {}
        for task_id, task in state.tasks.items():
            code = self.planner.model_client.generate_code_with_contract(task)
            generated_code[task_id] = code
            task.generated_code = code
        return generated_code
    
    def _generate_realistic_sample_inputs(self, contract: TaskContract) -> Dict[str, Any]:
        """Generate realistic sample inputs using Faker"""
        sample_inputs = {}
        
        for input_contract in contract.inputs:
            if not input_contract.required:
                continue
            
            sample_value = self._generate_realistic_sample_value(input_contract.data_type)
            sample_inputs[input_contract.name] = sample_value
        
        return sample_inputs
    
    def _generate_realistic_sample_value(self, data_type: DataType) -> Any:
        """Generate realistic sample values using Faker"""
        faker_samples = {
            DataType.STRING: lambda: self.faker.text(max_nb_chars=50),
            DataType.INTEGER: lambda: self.faker.random_int(min=1, max=1000),
            DataType.FLOAT: lambda: round(self.faker.pyfloat(positive=True), 2),
            DataType.DECIMAL: lambda: round(self.faker.pydecimal(positive=True), 2),
            DataType.BOOLEAN: lambda: self.faker.boolean(),
            DataType.NULL: lambda: None,
            
            # Date and time types
            DataType.DATE: lambda: self.faker.date().isoformat(),
            DataType.TIME: lambda: self.faker.time().isoformat(),
            DataType.DATE_TIME: lambda: self.faker.date_time().isoformat(),
            DataType.TIMESTAMP: lambda: int(self.faker.date_time().timestamp()),
            DataType.TIMEZONE: lambda: self.faker.timezone(),
            DataType.DURATION: lambda: self.faker.random_int(min=1, max=86400),
            
            # Structured data types
            DataType.JSON: lambda: {"name": self.faker.name(), "value": self.faker.random_int()},
            DataType.XML: lambda: f"<root><item>{self.faker.word()}</item></root>",
            DataType.YAML: lambda: f"name: {self.faker.name()}\nvalue: {self.faker.random_int()}",
            DataType.CSV: lambda: f"name,age\n{self.faker.name()},{self.faker.random_int(min=18, max=80)}",
            DataType.ARRAY: lambda: [self.faker.word() for _ in range(3)],
            DataType.LIST: lambda: [self.faker.word() for _ in range(3)],
            DataType.DICTIONARY: lambda: {self.faker.word(): self.faker.word() for _ in range(3)},
            DataType.OBJECT: lambda: {"id": self.faker.uuid4(), "name": self.faker.name()},
            
            # File types (generate temporary file paths)
            DataType.FILE: lambda: f"/tmp/{self.faker.file_name()}",
            DataType.BINARY: lambda: self.faker.binary(length=64),
            DataType.TEXT_FILE: lambda: f"/tmp/{self.faker.file_name(extension='txt')}",
            DataType.IMAGE: lambda: f"/tmp/{self.faker.file_name(extension='jpg')}",
            DataType.VIDEO: lambda: f"/tmp/{self.faker.file_name(extension='mp4')}",
            DataType.AUDIO: lambda: f"/tmp/{self.faker.file_name(extension='mp3')}",
            DataType.DOCUMENT: lambda: f"/tmp/{self.faker.file_name(extension='pdf')}",
            
            # Document formats
            DataType.PDF: lambda: f"/tmp/{self.faker.file_name(extension='pdf')}",
            DataType.WORD_DOC: lambda: f"/tmp/{self.faker.file_name(extension='docx')}",
            DataType.EXCEL: lambda: f"/tmp/{self.faker.file_name(extension='xlsx')}",
            DataType.POWERPOINT: lambda: f"/tmp/{self.faker.file_name(extension='pptx')}",
            DataType.HTML: lambda: f"<html><body><h1>{self.faker.sentence()}</h1></body></html>",
            DataType.MARKDOWN: lambda: f"# {self.faker.sentence()}\n\n{self.faker.paragraph()}",
            
            # Network and web types
            DataType.URL: lambda: self.faker.url(),
            DataType.EMAIL: lambda: self.faker.email(),
            DataType.IP_ADDRESS: lambda: self.faker.ipv4(),
            DataType.MAC_ADDRESS: lambda: self.faker.mac_address(),
            DataType.UUID: lambda: self.faker.uuid4(),
            
            # Database types
            DataType.DATABASE_RECORD: lambda: {"id": self.faker.random_int(), "name": self.faker.name()},
            DataType.PRIMARY_KEY: lambda: self.faker.random_int(min=1, max=999999),
            DataType.FOREIGN_KEY: lambda: self.faker.random_int(min=1, max=999999),
            DataType.BLOB: lambda: self.faker.binary(length=128),
            DataType.CLOB: lambda: self.faker.text(max_nb_chars=1000),
            
            # Geographic types
            DataType.COORDINATE: lambda: [float(self.faker.latitude()), float(self.faker.longitude())],
            DataType.LATITUDE: lambda: float(self.faker.latitude()),
            DataType.LONGITUDE: lambda: float(self.faker.longitude()),
            DataType.ADDRESS: lambda: self.faker.address(),
            DataType.POSTAL_CODE: lambda: self.faker.postcode(),
            
            # Financial types
            DataType.CURRENCY: lambda: self.faker.currency_code(),
            DataType.PRICE: lambda: round(self.faker.pyfloat(positive=True, max_value=10000), 2),
            DataType.PERCENTAGE: lambda: round(self.faker.pyfloat(positive=True, max_value=100), 1),
            
            # Security types
            DataType.PASSWORD: lambda: self.faker.password(length=12),
            DataType.TOKEN: lambda: self.faker.sha256(),
            DataType.API_KEY: lambda: f"sk-{self.faker.lexify('?' * 48)}",
            DataType.ENCRYPTED_DATA: lambda: self.faker.sha256(),
            DataType.HASH: lambda: self.faker.md5(),
            
            # Communication types
            DataType.PHONE_NUMBER: lambda: self.faker.phone_number(),
            DataType.MESSAGE: lambda: self.faker.sentence(),
            DataType.NOTIFICATION: lambda: {"message": self.faker.sentence(), "type": "info"},
            
            # Measurement types
            DataType.METRIC: lambda: round(self.faker.pyfloat(positive=True), 2),
            DataType.UNIT_OF_MEASURE: lambda: self.faker.random_element(["meters", "kilograms", "seconds", "celsius"]),
            DataType.QUANTITY: lambda: self.faker.random_int(min=1, max=1000),
            
            # Custom types
            DataType.REGEX_PATTERN: lambda: r"^\d{3}-\d{2}-\d{4}$",
            DataType.COLOR_CODE: lambda: self.faker.hex_color(),
            DataType.VERSION_NUMBER: lambda: f"{self.faker.random_int(min=1, max=10)}.{self.faker.random_int(min=0, max=20)}.{self.faker.random_int(min=0, max=50)}",
            DataType.STATUS_CODE: lambda: self.faker.random_element([200, 201, 400, 404, 500]),
        }
        
        generator = faker_samples.get(data_type)
        if generator:
            try:
                return generator()
            except Exception:
                return f"sample_{data_type.value}"
        
        return f"sample_{data_type.value}"
    
    def get_supported_enums(self) -> Dict[str, List[str]]:
        """Get all supported enum values"""
        return {
            "data_types": [dt.value for dt in DataType],
            "task_statuses": [status.value for status in TaskStatus],
            "resource_types": [rt.value for rt in ResourceType]
        }
    
    def validate_enum_values(self, data: Dict[str, Any]) -> Dict[str, List[str]]:
        """Validate enum values with specific error messages"""
        errors = {}
        
        try:
            supported = self.get_supported_enums()
            
            if "data_types" in data:
                invalid_types = [dt for dt in data["data_types"] if dt not in supported["data_types"]]
                if invalid_types:
                    errors["data_types"] = [f"Unsupported data types: {invalid_types}"]
            
            if "task_statuses" in data:
                invalid_statuses = [status for status in data["task_statuses"] if status not in supported["task_statuses"]]
                if invalid_statuses:
                    errors["task_statuses"] = [f"Unsupported task statuses: {invalid_statuses}"]
            
            if "resource_types" in data:
                invalid_resources = [rt for rt in data["resource_types"] if rt not in supported["resource_types"]]
                if invalid_resources:
                    errors["resource_types"] = [f"Unsupported resource types: {invalid_resources}"]
                    
        except KeyError as e:
            errors["validation"] = [f"Missing required field: {str(e)}"]
        except Exception as e:
            errors["validation"] = [f"Validation error: {str(e)}"]
        
        return errors

# Enhanced utility functions with proper error handling

def get_enum_suggestions(partial_value: str, enum_class) -> List[str]:
    """Get enum suggestions with error handling"""
    try:
        partial_lower = partial_value.lower()
        suggestions = []
        
        for enum_item in enum_class:
            if partial_lower in enum_item.value.lower():
                suggestions.append(enum_item.value)
        
        return sorted(suggestions)
    except (AttributeError, TypeError):
        return []

def get_data_type_suggestions(partial_value: str) -> List[str]:
    """Get DataType suggestions"""
    return get_enum_suggestions(partial_value, DataType)

def get_task_status_suggestions(partial_value: str) -> List[str]:
    """Get TaskStatus suggestions"""
    return get_enum_suggestions(partial_value, TaskStatus)

def get_resource_type_suggestions(partial_value: str) -> List[str]:
    """Get ResourceType suggestions"""
    return get_enum_suggestions(partial_value, ResourceType)

def get_resource_compatibility_matrix() -> Dict[ResourceType, List[ResourceType]]:
    """Get resource compatibility matrix"""
    return {
        # Human resources
        ResourceType.DEVELOPER: [ResourceType.QA, ResourceType.DESIGNER, ResourceType.PRODUCT_MANAGER],
        ResourceType.QA: [ResourceType.DEVELOPER, ResourceType.BUSINESS_ANALYST],
        ResourceType.DESIGNER: [ResourceType.DEVELOPER, ResourceType.PRODUCT_MANAGER],
        ResourceType.PRODUCT_MANAGER: [ResourceType.DEVELOPER, ResourceType.DESIGNER, ResourceType.BUSINESS_ANALYST],
        ResourceType.DEVOPS_ENGINEER: [ResourceType.DEVELOPER, ResourceType.SECURITY_ANALYST],
        ResourceType.DATA_SCIENTIST: [ResourceType.DEVELOPER, ResourceType.BUSINESS_ANALYST],
        ResourceType.SECURITY_ANALYST: [ResourceType.DEVOPS_ENGINEER, ResourceType.DEVELOPER],
        ResourceType.BUSINESS_ANALYST: [ResourceType.PRODUCT_MANAGER, ResourceType.DATA_SCIENTIST],
        
        # Infrastructure
        ResourceType.DATABASE: [ResourceType.CACHE, ResourceType.BACKUP, ResourceType.STORAGE],
        ResourceType.CACHE: [ResourceType.DATABASE, ResourceType.LOAD_BALANCER],
        ResourceType.MESSAGE_QUEUE: [ResourceType.MICROSERVICE, ResourceType.API_ENDPOINT],
        ResourceType.LOAD_BALANCER: [ResourceType.WEB_SERVER, ResourceType.CDN],
        ResourceType.CDN: [ResourceType.LOAD_BALANCER, ResourceType.WEB_SERVER],
        ResourceType.STORAGE: [ResourceType.DATABASE, ResourceType.BACKUP],
        
        # Compute
        ResourceType.COMPUTE: [ResourceType.MEMORY, ResourceType.CPU, ResourceType.GPU],
        ResourceType.CPU: [ResourceType.MEMORY, ResourceType.COMPUTE],
        ResourceType.GPU: [ResourceType.MEMORY, ResourceType.COMPUTE],
        ResourceType.MEMORY: [ResourceType.CPU, ResourceType.GPU],
        ResourceType.CONTAINER: [ResourceType.VIRTUAL_MACHINE, ResourceType.COMPUTE],
        ResourceType.VIRTUAL_MACHINE: [ResourceType.CONTAINER],
        ResourceType.SERVERLESS_FUNCTION: [ResourceType.API_ENDPOINT],
        
        # Network
        ResourceType.NETWORK: [ResourceType.FIREWALL, ResourceType.VPN, ResourceType.DNS],
        ResourceType.BANDWIDTH: [ResourceType.NETWORK, ResourceType.CDN],
        ResourceType.VPN: [ResourceType.NETWORK, ResourceType.FIREWALL],
        ResourceType.FIREWALL: [ResourceType.NETWORK, ResourceType.VPN],
        ResourceType.DNS: [ResourceType.NETWORK],
    }

def suggest_complementary_resources(primary_resource: ResourceType) -> List[ResourceType]:
    """Suggest complementary resources"""
    compatibility_matrix = get_resource_compatibility_matrix()
    return compatibility_matrix.get(primary_resource, [])

def get_data_type_validation_rules(data_type: DataType) -> List[str]:
    """Get validation rules for data types"""
    validation_rules = {
        DataType.STRING: ["not empty", "length > 0", "length < 1000"],
        DataType.INTEGER: ["positive", "min 0", "max 2147483647"],
        DataType.FLOAT: ["positive", "min 0.0"],
        DataType.EMAIL: ["contains @", "contains .", "not empty"],
        DataType.URL: ["starts with http", "not empty"],
        DataType.PASSWORD: ["length > 8", "not empty"],
        DataType.PHONE_NUMBER: ["length > 10", "not empty"],
        DataType.PERCENTAGE: ["min 0", "max 100"],
        DataType.PRICE: ["positive", "min 0"],
        DataType.LATITUDE: ["min -90", "max 90"],
        DataType.LONGITUDE: ["min -180", "max 180"],
        DataType.STATUS_CODE: ["min 100", "max 599"],
        DataType.UUID: ["length = 36"],
        DataType.JSON: ["not empty"],
        DataType.ARRAY: ["not empty"],
        DataType.DICTIONARY: ["not empty"],
    }
    
    return validation_rules.get(data_type, ["not empty"])

# Example usage and testing utilities

def create_sample_planning_request() -> PlanRequest:
    """Create a sample planning request for testing"""
    return PlanRequest(
        description="Create a secure web application with user authentication, data processing, and reporting capabilities",
        requirements=[
            "User registration and login system with secure password handling",
            "Data import from CSV files with validation",
            "Generate analytics reports with charts",
            "Send email notifications to users",
            "API endpoints for mobile app integration"
        ],
        team_resources=[
            "senior_developer",
            "qa_engineer", 
            "database_admin",
            "ui_designer",
            "security_analyst"
        ],
        enforce_contracts=True,
        preferred_execution_environment="python",
        use_real_pddl_solver=False,
        solver_timeout=60
    )

def demo_secure_dynamic_usage():
    """Demonstrate the secure dynamic enum usage"""
    print("=== Secure Dynamic Contract Planner Demo ===\n")
    
    print("Security Features:")
    print("   No eval() or exec() in main process")
    print("   Network-disabled containers")
    print("   Resource limits and timeouts")
    print("   Proper exception handling")
    print("   Input/output validation")
    print()
    
    print("Architecture Features:")
    print("   Centralized status transitions")
    print("   Real PDDL solver integration")
    print("   Optimized enum parsing")
    print("   Consolidated resource management")
    print("   Realistic sample data generation")
    print()
    
    # Show supported values
    print("Supported Data Types (sample):")
    for i, dt in enumerate(list(DataType)[:10]):
        print(f"  - {dt.value}")
    print(f"  ... and {len(DataType) - 10} more")
    print()
    
    print("Supported Task Statuses (sample):")
    for i, status in enumerate(list(TaskStatus)[:10]):
        print(f"  - {status.value}")
    print(f"  ... and {len(TaskStatus) - 10} more")
    print()
    
    print("Valid Status Transitions (sample):")
    for from_status, to_statuses in list(VALID_STATUS_TRANSITIONS.items())[:5]:
        print(f"  {from_status.value} -> {[s.value for s in to_statuses]}")
    print("  ... and more transitions")
    print()

if __name__ == "__main__":
    try:
        # Run the demo
        demo_secure_dynamic_usage()
        
        # Create and test the secure API
        api = SecureContractPlanningAPI()
        sample_request = create_sample_planning_request()
        
        print("=== Testing Secure Planning API ===")
        response = api.create_plan(sample_request)
        
        print(f" Execution Ready: {response.execution_ready}")
        print(f" Generated {len(response.generated_code)} code modules")
        print(f" Validation Results: {len(response.validation_results)} tasks validated")
        print(f" Solver Used: {response.solver_used}")
        print(f" Status Transitions: {len(response.status_transitions)} transitions planned")
        
        # Test enum validation
        print("\n=== Testing Enum Validation ===")
        test_data = {
            "data_types": ["string", "integer", "invalid_type"],
            "task_statuses": ["pending", "completed", "invalid_status"],
            "resource_types": ["developer", "database", "invalid_resource"]
        }
        
        validation_errors = api.validate_enum_values(test_data)
        if validation_errors:
            print("Validation errors found (as expected):")
            for category, errors in validation_errors.items():
                print(f"  {category}: {errors}")
        else:
            print("No validation errors found")
        
    except (SecurityError, ValidationError, PlanningError) as e:
        print(f"Planning error: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")
    finally:
        try:
            api.close()
        except:
            pass
</file>

<file path="pddl_classes.py">
import json
from numpy import integer
from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum


class TaskStatus(str, Enum):
    # Initial states
    PENDING = "pending"
    QUEUED = "queued"
    SCHEDULED = "scheduled"
    READY = "ready"
    
    # Active states
    IN_PROGRESS = "in_progress"
    RUNNING = "running"
    PROCESSING = "processing"
    EXECUTING = "executing"
    
    # Waiting states
    BLOCKED = "blocked"
    WAITING = "waiting"
    PAUSED = "paused"
    SUSPENDED = "suspended"
    ON_HOLD = "on_hold"
    
    # Completion states
    COMPLETED = "completed"
    SUCCESS = "success"
    FINISHED = "finished"
    
    # Failure states
    FAILED = "failed"
    ERROR = "error"
    TIMEOUT = "timeout"
    ABORTED = "aborted"
    CANCELLED = "cancelled"
    
    # Review states
    UNDER_REVIEW = "under_review"
    APPROVED = "approved"
    REJECTED = "rejected"
    
    # Retry states
    RETRYING = "retrying"
    RETRY_PENDING = "retry_pending"


class ResourceType(str, Enum):
    # Human resources
    DEVELOPER = "developer"
    QA = "qa"
    DESIGNER = "designer"
    PRODUCT_MANAGER = "product_manager"
    DEVOPS_ENGINEER = "devops_engineer"
    DATA_SCIENTIST = "data_scientist"
    SECURITY_ANALYST = "security_analyst"
    BUSINESS_ANALYST = "business_analyst"
    
    # Infrastructure resources
    DATABASE = "database"
    CACHE = "cache"
    MESSAGE_QUEUE = "message_queue"
    LOAD_BALANCER = "load_balancer"
    CDN = "cdn"
    STORAGE = "storage"
    BACKUP = "backup"
    
    # Compute resources
    COMPUTE = "compute"
    CPU = "cpu"
    GPU = "gpu"
    MEMORY = "memory"
    CONTAINER = "container"
    VIRTUAL_MACHINE = "virtual_machine"
    SERVERLESS_FUNCTION = "serverless_function"
    
    # Network resources
    NETWORK = "network"
    BANDWIDTH = "bandwidth"
    VPN = "vpn"
    FIREWALL = "firewall"
    DNS = "dns"
    
    # Application resources
    API_ENDPOINT = "api_endpoint"
    MICROSERVICE = "microservice"
    WEB_SERVER = "web_server"
    APPLICATION_SERVER = "application_server"
    
    # File and data resources
    FILE_SYSTEM = "file_system"
    OBJECT_STORAGE = "object_storage"
    DATA_WAREHOUSE = "data_warehouse"
    DATA_LAKE = "data_lake"
    
    # External resources
    THIRD_PARTY_API = "third_party_api"
    EXTERNAL_SERVICE = "external_service"
    PAYMENT_GATEWAY = "payment_gateway"
    
    # Security resources
    SSL_CERTIFICATE = "ssl_certificate"
    SECRET_MANAGER = "secret_manager"
    AUTHENTICATION_SERVICE = "authentication_service"
    
    # Monitoring resources
    MONITORING_SYSTEM = "monitoring_system"
    LOGGING_SERVICE = "logging_service"
    ALERTING_SYSTEM = "alerting_system"


class DataType(str, Enum):
    # Primitive types
    STRING = "string"
    INTEGER = "integer"
    FLOAT = "float"
    DECIMAL = "decimal"
    BOOLEAN = "boolean"
    NULL = "null"
    
    # Date and time types
    DATE = "date"
    TIME = "time"
    DATE_TIME = "datetime"
    TIMESTAMP = "timestamp"
    TIMEZONE = "timezone"
    DURATION = "duration"
    
    # Structured data types
    JSON = "json"
    XML = "xml"
    YAML = "yaml"
    CSV = "csv"
    ARRAY = "array"
    LIST = "list"
    DICTIONARY = "dictionary"
    OBJECT = "object"
    
    # File types
    FILE = "file"
    BINARY = "binary"
    TEXT_FILE = "text_file"
    IMAGE = "image"
    VIDEO = "video"
    AUDIO = "audio"
    DOCUMENT = "document"
    
    # Document formats
    PDF = "pdf"
    WORD_DOC = "word_doc"
    EXCEL = "excel"
    POWERPOINT = "powerpoint"
    HTML = "html"
    MARKDOWN = "markdown"
    
    # Network and web types
    URL = "url"
    EMAIL = "email"
    IP_ADDRESS = "ip_address"
    MAC_ADDRESS = "mac_address"
    UUID = "uuid"
    
    # Database types
    DATABASE_RECORD = "database_record"
    PRIMARY_KEY = "primary_key"
    FOREIGN_KEY = "foreign_key"
    BLOB = "blob"
    CLOB = "clob"
    
    # Geographic and location types
    COORDINATE = "coordinate"
    LATITUDE = "latitude"
    LONGITUDE = "longitude"
    ADDRESS = "address"
    POSTAL_CODE = "postal_code"
    
    # Financial types
    CURRENCY = "currency"
    PRICE = "price"
    PERCENTAGE = "percentage"
    
    # Security types
    PASSWORD = "password"
    TOKEN = "token"
    API_KEY = "api_key"
    ENCRYPTED_DATA = "encrypted_data"
    HASH = "hash"
    
    # Communication types
    PHONE_NUMBER = "phone_number"
    MESSAGE = "message"
    NOTIFICATION = "notification"
    
    # Measurement types
    METRIC = "metric"
    UNIT_OF_MEASURE = "unit_of_measure"
    QUANTITY = "quantity"
    
    # Custom types
    REGEX_PATTERN = "regex_pattern"
    COLOR_CODE = "color_code"
    VERSION_NUMBER = "version_number"
    STATUS_CODE = "status_code"

class InputContract(BaseModel):
    """Defines required inputs for a task"""
    name: str
    data_type: DataType
    required: bool = True
    validation_rules: List[str] = Field(default_factory=list)
    example_value: Optional[str] = None
    description: str = ""

class OutputContract(BaseModel):
    """Defines expected outputs from a task"""
    name: str
    data_type: DataType
    validation_rules: List[str] = Field(default_factory=list)
    example_value: Optional[str] = None
    description: str = ""
    
class TaskContract(BaseModel):
    """Complete input/output contract for a task"""
    task_id: str
    inputs: List[InputContract] = Field(default_factory=list)
    outputs: List[OutputContract] = Field(default_factory=list)
    preconditions: List[str] = Field(default_factory=list)
    postconditions: List[str] = Field(default_factory=list)
    side_effects: List[str] = Field(default_factory=list)

class Task(BaseModel):
    id: str
    name: str
    description: str
    duration_hours: int = Field(gt=0)
    dependencies: List[str] = Field(default_factory=list)
    required_resources: List[str] = Field(default_factory=list)
    status: TaskStatus = TaskStatus.PENDING
    contract: TaskContract
    generated_code: Optional[str] = None
    execution_environment: str = "python"

class Resource(BaseModel):
    id: str
    name: str
    resource_type: ResourceType
    available: bool = True
    capacity: int = Field(default=1, gt=0)
    properties: Dict[str, Any] = Field(default_factory=dict)

class ExecutionContext(BaseModel):
    """Runtime context for task execution"""
    task_id: str
    inputs: Dict[str, Any]
    outputs: Dict[str, Any] = Field(default_factory=dict)
    errors: List[str] = Field(default_factory=list)
    execution_trace: List[str] = Field(default_factory=list)
    resource_state: Dict[str, Any] = Field(default_factory=dict)

class PlanningState(BaseModel):
    tasks: Dict[str, Task]
    resources: Dict[str, Resource]
    completed_tasks: List[str] = Field(default_factory=list)
    failed_tasks: List[str] = Field(default_factory=list)
    current_time: int = Field(default=0, ge=0)
    available_resources: Optional[List[str]] = None
    execution_contexts: Dict[str, ExecutionContext] = Field(default_factory=dict)
    global_state: Dict[str, Any] = Field(default_factory=dict)
    
    def model_post_init(self, __context: Any) -> None:
        if self.available_resources is None:
            self.available_resources = [r.id for r in self.resources.values() if r.available]

class ValidationResult(BaseModel):
    is_valid: bool
    errors: List[str] = Field(default_factory=list)
    warnings: List[str] = Field(default_factory=list)
    execution_trace: List[str] = Field(default_factory=list)
    val_output: str = ""
    contract_violations: List[str] = Field(default_factory=list)
</file>

<file path="pddl_client.py">
from app.utils.ollama.ollama_config import client
from app.utils.ollama.ollama_functions import call_model
from .pddl_classes import Task
import re

class ModelClient:
    """Wrapper for your existing call_model function with contract-aware code generation"""
    
    def __init__(self, model: str = "codestral:latest"):
        self.model = model
    
    def generate(self, prompt: str, system_prompt: str = None) -> str:
        """Generate text using your call_model function"""
        try: 
            response = call_model(prompt, role="user", model=self.model, system_prompt = system_prompt)
            
            # Extract content from response (adjust based on your response format)
            if hasattr(response, 'choices') and response.choices:
                return response.choices[0].message.content.strip()
            elif hasattr(response, 'content'):
                return response.content.strip()
            else:
                return str(response).strip()
                
        except Exception as e:
            return f"Error: {e}"
    
    def generate_code_with_contract(self, task: Task) -> str:
        """Generate code that enforces the task contract"""
        
        # Build input validation
        input_validation = []
        for inp in task.contract.inputs:
            validation_code = f"# Validate {inp.name}: {inp.data_type.value}"
            if inp.required:
                validation_code += f"\nassert '{inp.name}' in inputs, 'Required input {inp.name} missing'"
            for rule in inp.validation_rules:
                validation_code += f"\n# Rule: {rule}"
            input_validation.append(validation_code)
        
        # Build output specification
        output_spec = []
        for out in task.contract.outputs:
            output_spec.append(f"'{out.name}': {out.data_type.value}  # {out.description}")
        
        system_prompt = f"""You are a code generation AI that MUST follow strict contracts.

Generate {task.execution_environment} code for this task:
- Task: {task.name}
- Description: {task.description}

CONTRACT REQUIREMENTS (MANDATORY):
Input Contract:
{chr(10).join(f"- {inp.name} ({inp.data_type.value}): {inp.description}" for inp in task.contract.inputs)}

Output Contract:
{chr(10).join(f"- {out.name} ({out.data_type.value}): {out.description}" for out in task.contract.outputs)}

Preconditions:
{chr(10).join(f"- {pre}" for pre in task.contract.preconditions)}

Postconditions:
{chr(10).join(f"- {post}" for post in task.contract.postconditions)}

CRITICAL RULES:
1. Function MUST accept inputs dict and return outputs dict
2. Validate ALL required inputs exist and have correct types
3. Generate ALL specified outputs with correct types
4. Raise clear exceptions if preconditions not met
5. Ensure postconditions are satisfied before returning
6. Add comprehensive error handling
7. Include type hints and docstrings
8. Make the function completely self-contained (black box)

Generate ONLY the function code, nothing else."""

        prompt = f"Generate the {task.execution_environment} function for: {task.name}"
        
        code = self.generate(prompt, system_prompt)
        return self._clean_generated_code(code)
    
    def _clean_generated_code(self, code: str) -> str:
        """Clean and format generated code"""
        # Remove markdown code blocks if present
        code = re.sub(r'```\w*\n', '', code)
        code = re.sub(r'```', '', code)
        return code.strip()
    
    def close(self):
        """No cleanup needed for your client"""
        pass

class NaturalLanguageParser:
    """Uses LLM to parse natural language into structured planning data"""
    
    def __init__(self, model_client: ModelClient):
        self.model_client = model_client
    
    def parse_requirements_to_tasks(self, user_request: str) -> dict:
        """Parse natural language request into structured task data"""
        
        system_prompt = """You are a project planning assistant. Parse the user's request into a structured JSON format for task planning.

Use ONLY these data types: "string", "integer", "boolean", "json", "file", "url", "database_record", "datatime"
resource_type must be exactly one of: "developer", "database", "api_endpoint", "file_system", "compute", "network", "qa"


Extract:
1. Tasks (with names, descriptions, estimated hours, dependencies)
2. Resources needed (people, equipment, etc.)
3. Contracts for each task (inputs, outputs, validation rules)

Return ONLY valid JSON in this format:
{
  "tasks": [
    {
      "id": "task_1",
      "name": "Task Name",
      "description": "Description",
      "duration_hours": 4,
      "dependencies": ["task_id_if_any"],
      "required_resources": ["resource_id"],
      "contract": {
        "task_id": "task_1",
        "inputs": [
          {
            "name": "input_name",
            "data_type": "string",
            "required": true,
            "validation_rules": ["not empty"],
            "description": "Input description"
          }
        ],
        "outputs": [
          {
            "name": "output_name", 
            "data_type": "json",
            "validation_rules": ["valid format"],
            "description": "Output description"
          }
        ],
        "preconditions": ["Condition that must be true before"],
        "postconditions": ["Condition that must be true after"],
        "side_effects": ["What changes in the system"]
      }
    }
  ],
  "resources": [
    {
      "id": "resource_1",
      "name": "Resource Name", 
      "resource_type": "developer",
      "available": true,
      "capacity": 1,
      "properties": {}
    }
  ]
}

Be specific and realistic with time estimates. Create logical task dependencies and comprehensive contracts."""

        prompt = f"Parse this project request: {user_request}"
        
        response = self.model_client.generate(prompt, system_prompt)
        
        try:
            # Extract JSON from response
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                response = json_match.group()
            
            import json
            parsed_data = json.loads(response)
            return parsed_data
        except json.JSONDecodeError as e:
            print(f"Error parsing LLM response as JSON: {e}")
            return self._create_fallback_structure(user_request)
    
    def _create_fallback_structure(self, user_request: str) -> dict:
        """Create a simple fallback structure if LLM parsing fails"""
        return {
            "tasks": [
                {
                    "id": "task_1",
                    "name": "Main Task",
                    "description": user_request,
                    "duration_hours": 8,
                    "dependencies": [],
                    "required_resources": ["person_1"],
                    "contract": {
                        "task_id": "task_1",
                        "inputs": [
                            {
                                "name": "requirements",
                                "data_type": "string",
                                "required": True,
                                "validation_rules": ["not empty"],
                                "description": "Task requirements"
                            }
                        ],
                        "outputs": [
                            {
                                "name": "result",
                                "data_type": "string", 
                                "validation_rules": ["not empty"],
                                "description": "Task result"
                            }
                        ],
                        "preconditions": ["Requirements available"],
                        "postconditions": ["Task completed"],
                        "side_effects": ["System updated"]
                    }
                }
            ],
            "resources": [
                {
                    "id": "person_1",
                    "name": "Team Member",
                    "resource_type": "developer",
                    "available": True,
                    "capacity": 1,
                    "properties": {}
                }
            ]
        }

class PlanExplainer:
    """Uses LLM to explain plans in natural language"""
    
    def __init__(self, model_client: ModelClient):
        self.model_client = model_client
    
    def explain_plan_with_validation(self, plan: list, validation_result, original_request: str) -> str:
        """Enhanced explanation that includes validation results"""
        
        system_prompt = """You are a project manager explaining a project plan to a team member. 

The plan has been validated using formal PDDL validation. Include:
1. Plan summary and timeline
2. Validation status (valid/invalid)
3. Any issues or warnings found
4. Confidence level in the plan
5. Recommendations

Be clear about the validation results and what they mean for plan reliability."""

        plan_summary = f"Original request: {original_request}\n\n"
        plan_summary += f"Plan validation: {' VALID' if validation_result.is_valid else ' INVALID'}\n\n"
        
        if validation_result.errors:
            plan_summary += f"Validation errors:\n"
            for error in validation_result.errors:
                plan_summary += f"- {error}\n"
            plan_summary += "\n"
        
        if validation_result.warnings:
            plan_summary += f"Validation warnings:\n"
            for warning in validation_result.warnings:
                plan_summary += f"- {warning}\n"
            plan_summary += "\n"
        
        plan_summary += "Generated plan:\n"
        for step in plan:
            if step.get("action") == "execute_task":
                plan_summary += f"- {step['task_name']}: {step['duration']} hours (Time {step['start_time']}-{step['end_time']})\n"
            elif step.get("action") == "error":
                plan_summary += f"- Issue: {step['message']}\n"
        
        prompt = f"Explain this validated project plan:\n\n{plan_summary}"
        
        return self.model_client.generate(prompt, system_prompt)
</file>

<file path="task_builder.py">
from .pddl_classes import Task, TaskContract, InputContract, OutputContract, DataType, TaskStatus
from .pddl_client import ModelClient
from .main import ContractValidator, get_data_type_validation_rules
from pathlib import Path
import json
from typing import Dict
import re
import uuid

class TaskBuilder:
    """Interactive task builder that helps users create and modify tasks."""
    
    def __init__(self, model_client=None):
        """Initialize task builder with optional model client for suggestions."""
        if model_client is None:
            self.model_client = ModelClient("codestral:latest")
        else:
            self.model_client = model_client
        self.contract_validator = ContractValidator()
        self.task_templates = self._load_task_templates()
    
    def _load_task_templates(self) -> Dict[str, Task]:
        """Load predefined task templates."""
        # Default templates for common tasks
        templates = {
            "data_processing": Task(
                id="data_processing_template",
                name="Process Data",
                description="Generic data processing task",
                duration_hours=1,
                contract=TaskContract(
                    task_id="data_processing_template",
                    inputs=[
                        InputContract(
                            name="input_data",
                            data_type=DataType.JSON,
                            required=True,
                            validation_rules=["not empty"],
                            description="Data to process"
                        )
                    ],
                    outputs=[
                        OutputContract(
                            name="processed_data",
                            data_type=DataType.JSON,
                            description="Processed data result"
                        )
                    ],
                    preconditions=["Input data must be valid JSON"],
                    postconditions=["Output contains processed data"]
                ),
                status=TaskStatus.PENDING,
                execution_environment="python"
            ),
            "api_call": Task(
                id="api_call_template",
                name="Call External API",
                description="Make a request to an external API",
                duration_hours=1,
                contract=TaskContract(
                    task_id="api_call_template",
                    inputs=[
                        InputContract(
                            name="url",
                            data_type=DataType.URL,
                            required=True,
                            validation_rules=["not empty", "starts with http"],
                            description="API endpoint URL"
                        ),
                        InputContract(
                            name="method",
                            data_type=DataType.STRING,
                            required=True,
                            validation_rules=["in GET,POST,PUT,DELETE"],
                            description="HTTP method"
                        ),
                        InputContract(
                            name="headers",
                            data_type=DataType.JSON,
                            required=False,
                            description="HTTP headers"
                        ),
                        InputContract(
                            name="body",
                            data_type=DataType.JSON,
                            required=False,
                            description="Request body"
                        )
                    ],
                    outputs=[
                        OutputContract(
                            name="response",
                            data_type=DataType.JSON,
                            description="API response"
                        ),
                        OutputContract(
                            name="status_code",
                            data_type=DataType.INTEGER,
                            description="HTTP status code"
                        )
                    ],
                    preconditions=["URL must be accessible"],
                    postconditions=["Response contains API result"]
                ),
                status=TaskStatus.PENDING,
                execution_environment="python"
            )
            # Add more templates here
        }
        # Try to load any saved templates
        try:
            custom_templates_path = Path("task_templates.json")
            if custom_templates_path.exists():
                custom_templates = json.loads(custom_templates_path.read_text())
                for template_id, template_data in custom_templates.items():
                    templates[template_id] = Task(**template_data)
        except Exception as e:
            print(f"Error loading custom templates: {e}")
        
        return templates
        
    def create_task_from_description(self, description: str) -> Task:
        """Create a new task from a natural language description."""
        system_prompt = """Create a well-defined task with appropriate contract from this description.
        Return a single valid JSON object representing the Task with all required fields:
        - id: a unique identifier
        - name: short descriptive name
        - description: longer explanation
        - duration_hours: estimated time to complete
        - contract: with inputs, outputs, preconditions, postconditions
        The contract should have appropriate data types and validation rules."""
        
        result = self.model_client.generate(description, system_prompt)
        
        try:
            # Extract JSON if embedded in markdown or other text
            json_match = re.search(r'\{.*\}', result, re.DOTALL)
            if json_match:
                result = json_match.group()
                
            task_data = json.loads(result)
            task = Task(**task_data)
            return task
        except Exception as e:
            raise ValueError(f"Failed to create task from description: {e}")
    
    def create_task_interactive(self) -> Task:
        """Guide the user through creating a task interactively."""
        print("=== Create New Task ===")
        
        # Basic task properties
        task_id = f"task_{uuid.uuid4().hex[:8]}"
        name = input("Task name: ")
        description = input("Task description: ")
        
        try:
            duration = int(input("Estimated duration in hours: "))
        except ValueError:
            duration = 1
            print("Invalid duration, defaulting to 1 hour")
        
        # Choose execution environment
        print("\nExecution environments: python, javascript, bash, other")
        execution_environment = input("Select execution environment (default: python): ").lower() or "python"
        
        # Create empty contract
        contract = TaskContract(
            task_id=task_id,
            inputs=[],
            outputs=[],
            preconditions=[],
            postconditions=[]
        )
        
        # Build inputs
        print("\n=== Define Input Parameters ===")
        while True:
            input_name = input("\nInput name (leave empty to finish): ")
            if not input_name:
                break
                
            print("Available data types:", ", ".join([dt.value for dt in DataType]))
            data_type_str = input("Data type (default: string): ") or "string"
            try:
                data_type = DataType(data_type_str.lower())
            except ValueError:
                print(f"Invalid data type. Using string instead.")
                data_type = DataType.STRING
                
            required = input("Required? (y/n, default: y): ").lower() != 'n'
            description = input("Description: ")
            
            # Get validation rules with suggestions
            print("Suggested validation rules for this data type:")
            suggested_rules = get_data_type_validation_rules(data_type)
            for i, rule in enumerate(suggested_rules):
                print(f"  {i+1}. {rule}")
                
            validation_rules = []
            while True:
                rule = input("Add validation rule (leave empty to finish): ")
                if not rule:
                    break
                validation_rules.append(rule)
                
            contract.inputs.append(InputContract(
                name=input_name,
                data_type=data_type,
                required=required,
                validation_rules=validation_rules,
                description=description
            ))
        
        # Build outputs
        print("\n=== Define Output Parameters ===")
        while True:
            output_name = input("\nOutput name (leave empty to finish): ")
            if not output_name:
                break
                
            print("Available data types:", ", ".join([dt.value for dt in DataType]))
            data_type_str = input("Data type (default: string): ") or "string"
            try:
                data_type = DataType(data_type_str.lower())
            except ValueError:
                print(f"Invalid data type. Using string instead.")
                data_type = DataType.STRING
                
            description = input("Description: ")
            
            # Get validation rules with suggestions
            print("Suggested validation rules for this data type:")
            suggested_rules = get_data_type_validation_rules(data_type)
            for i, rule in enumerate(suggested_rules):
                print(f"  {i+1}. {rule}")
                
            validation_rules = []
            while True:
                rule = input("Add validation rule (leave empty to finish): ")
                if not rule:
                    break
                validation_rules.append(rule)
                
            contract.outputs.append(OutputContract(
                name=output_name,
                data_type=data_type,
                validation_rules=validation_rules,
                description=description
            ))
        
        # Preconditions and postconditions
        print("\n=== Define Conditions ===")
        
        while True:
            precondition = input("Add precondition (leave empty to finish): ")
            if not precondition:
                break
            contract.preconditions.append(precondition)
            
        while True:
            postcondition = input("Add postcondition (leave empty to finish): ")
            if not postcondition:
                break
            contract.postconditions.append(postcondition)
            
        # Create and return the task
        task = Task(
            id=task_id,
            name=name,
            description=description,
            duration_hours=duration,
            dependencies=[],
            required_resources=[],
            contract=contract,
            status=TaskStatus.PENDING,
            execution_environment=execution_environment
        )
        
        print("\nTask created successfully!")
        return task
    
    def create_task_from_template(self, template_id: str) -> Task:
        """Create a new task based on a template."""
        if template_id not in self.task_templates:
            raise ValueError(f"Template '{template_id}' not found")
            
        template = self.task_templates[template_id]
        
        # Create a deep copy with a new ID
        new_task_data = template.model_dump()
        new_task_data['id'] = f"{template_id}_{uuid.uuid4().hex[:8]}"
        new_task_data['contract']['task_id'] = new_task_data['id']
        
        return Task(**new_task_data)
    
    def modify_task(self, task: Task) -> Task:
        """Modify an existing task interactively."""
        print(f"=== Modifying Task: {task.name} ===")
        
        # Show current properties and allow modifications
        print("\nCurrent properties:")
        print(f"ID: {task.id}")
        print(f"Name: {task.name}")
        print(f"Description: {task.description}")
        print(f"Duration: {task.duration_hours} hours")
        print(f"Status: {task.status.value}")
        print(f"Execution environment: {task.execution_environment}")
        
        # Allow modifications to basic properties
        name = input("\nNew name (leave empty to keep current): ")
        if name:
            task.name = name
            
        description = input("New description (leave empty to keep current): ")
        if description:
            task.description = description
            
        duration_str = input("New duration in hours (leave empty to keep current): ")
        if duration_str:
            try:
                task.duration_hours = int(duration_str)
            except ValueError:
                print("Invalid duration, keeping current value")
                
        env = input("New execution environment (leave empty to keep current): ")
        if env:
            task.execution_environment = env
            
        # Modify contract
        print("\nWould you like to modify the contract? (y/n): ")
        if input().lower() == 'y':
            self._modify_contract(task.contract)
            
        # Dependencies
        print("\nCurrent dependencies:", task.dependencies)
        print("Would you like to modify dependencies? (y/n): ")
        if input().lower() == 'y':
            task.dependencies = []
            while True:
                dep = input("Add dependency ID (leave empty to finish): ")
                if not dep:
                    break
                task.dependencies.append(dep)
                
        # Resources
        print("\nCurrent required resources:", task.required_resources)
        print("Would you like to modify required resources? (y/n): ")
        if input().lower() == 'y':
            task.required_resources = []
            while True:
                res = input("Add resource ID (leave empty to finish): ")
                if not res:
                    break
                task.required_resources.append(res)
                
        print("\nTask modified successfully!")
        return task
    
    def _modify_contract(self, contract: TaskContract) -> None:
        """Helper method to modify a task's contract."""
        # Modify inputs
        print("\n=== Current Inputs ===")
        for i, inp in enumerate(contract.inputs):
            print(f"{i+1}. {inp.name} ({inp.data_type.value}): {inp.description}")
        
        print("\nWould you like to modify inputs? (y/n): ")
        if input().lower() == 'y':
            # Options to add, modify or remove inputs
            print("1. Add new input")
            print("2. Modify existing input")
            print("3. Remove input")
            choice = input("Select option: ")
            
            if choice == "1":
                # Add new input (reuse code from create_task_interactive)
                print("\n=== Add New Input ===")
                input_name = input("Input name: ")
                print("Available data types:", ", ".join([dt.value for dt in DataType]))
                data_type_str = input("Data type (default: string): ") or "string"
                try:
                    data_type = DataType(data_type_str.lower())
                except ValueError:
                    print(f"Invalid data type. Using string instead.")
                    data_type = DataType.STRING
                    
                required = input("Required? (y/n, default: y): ").lower() != 'n'
                description = input("Description: ")
                
                validation_rules = []
                while True:
                    rule = input("Add validation rule (leave empty to finish): ")
                    if not rule:
                        break
                    validation_rules.append(rule)
                    
                contract.inputs.append(InputContract(
                    name=input_name,
                    data_type=data_type,
                    required=required,
                    validation_rules=validation_rules,
                    description=description
                ))
                
            elif choice == "2":
                # Modify existing input
                try:
                    idx = int(input("Enter input number to modify: ")) - 1
                    if 0 <= idx < len(contract.inputs):
                        inp = contract.inputs[idx]
                        
                        name = input(f"New name (current: {inp.name}): ")
                        if name:
                            inp.name = name
                            
                        data_type_str = input(f"New data type (current: {inp.data_type.value}): ")
                        if data_type_str:
                            try:
                                inp.data_type = DataType(data_type_str.lower())
                            except ValueError:
                                print("Invalid data type. Keeping current.")
                                
                        required_str = input(f"Required? (y/n, current: {'y' if inp.required else 'n'}): ")
                        if required_str.lower() in ('y', 'n'):
                            inp.required = required_str.lower() == 'y'
                            
                        description = input(f"New description (current: {inp.description}): ")
                        if description:
                            inp.description = description
                            
                        print("Current validation rules:", inp.validation_rules)
                        print("Would you like to modify validation rules? (y/n): ")
                        if input().lower() == 'y':
                            inp.validation_rules = []
                            while True:
                                rule = input("Add validation rule (leave empty to finish): ")
                                if not rule:
                                    break
                                inp.validation_rules.append(rule)
                    else:
                        print("Invalid input index")
                except ValueError:
                    print("Invalid input")
                    
            elif choice == "3":
                # Remove input
                try:
                    idx = int(input("Enter input number to remove: ")) - 1
                    if 0 <= idx < len(contract.inputs):
                        removed = contract.inputs.pop(idx)
                        print(f"Removed input: {removed.name}")
                    else:
                        print("Invalid input index")
                except ValueError:
                    print("Invalid input")
                    
        # Similar structure for outputs
        print("\n=== Current Outputs ===")
        for i, out in enumerate(contract.outputs):
            print(f"{i+1}. {out.name} ({out.data_type.value}): {out.description}")
        
        print("\nWould you like to modify outputs? (y/n): ")
        if input().lower() == 'y':
            # Options to add, modify or remove outputs
            print("1. Add new output")
            print("2. Modify existing output")
            print("3. Remove output")
            choice = input("Select option: ")
            
            if choice == "1":
                # Add new output
                print("\n=== Add New Output ===")
                output_name = input("Output name: ")
                print("Available data types:", ", ".join([dt.value for dt in DataType]))
                data_type_str = input("Data type (default: string): ") or "string"
                try:
                    data_type = DataType(data_type_str.lower())
                except ValueError:
                    print(f"Invalid data type. Using string instead.")
                    data_type = DataType.STRING
                    
                description = input("Description: ")
                
                validation_rules = []
                while True:
                    rule = input("Add validation rule (leave empty to finish): ")
                    if not rule:
                        break
                    validation_rules.append(rule)
                    
                contract.outputs.append(OutputContract(
                    name=output_name,
                    data_type=data_type,
                    validation_rules=validation_rules,
                    description=description
                ))
                
            elif choice == "2":
                # Modify existing output (similar to inputs)
                try:
                    idx = int(input("Enter output number to modify: ")) - 1
                    if 0 <= idx < len(contract.outputs):
                        out = contract.outputs[idx]
                        
                        name = input(f"New name (current: {out.name}): ")
                        if name:
                            out.name = name
                            
                        data_type_str = input(f"New data type (current: {out.data_type.value}): ")
                        if data_type_str:
                            try:
                                out.data_type = DataType(data_type_str.lower())
                            except ValueError:
                                print("Invalid data type. Keeping current.")
                                
                        description = input(f"New description (current: {out.description}): ")
                        if description:
                            out.description = description
                            
                        print("Current validation rules:", out.validation_rules)
                        print("Would you like to modify validation rules? (y/n): ")
                        if input().lower() == 'y':
                            out.validation_rules = []
                            while True:
                                rule = input("Add validation rule (leave empty to finish): ")
                                if not rule:
                                    break
                                out.validation_rules.append(rule)
                    else:
                        print("Invalid output index")
                except ValueError:
                    print("Invalid input")
                    
            elif choice == "3":
                # Remove output
                try:
                    idx = int(input("Enter output number to remove: ")) - 1
                    if 0 <= idx < len(contract.outputs):
                        removed = contract.outputs.pop(idx)
                        print(f"Removed output: {removed.name}")
                    else:
                        print("Invalid output index")
                except ValueError:
                    print("Invalid input")
                    
        # Modify preconditions and postconditions
        print("\nCurrent preconditions:", contract.preconditions)
        print("Would you like to modify preconditions? (y/n): ")
        if input().lower() == 'y':
            contract.preconditions = []
            while True:
                precondition = input("Add precondition (leave empty to finish): ")
                if not precondition:
                    break
                contract.preconditions.append(precondition)
                
        print("\nCurrent postconditions:", contract.postconditions)
        print("Would you like to modify postconditions? (y/n): ")
        if input().lower() == 'y':
            contract.postconditions = []
            while True:
                postcondition = input("Add postcondition (leave empty to finish): ")
                if not postcondition:
                    break
                contract.postconditions.append(postcondition)
</file>

<file path="task_execution_manager.py">
from .pddl_classes import Task, ExecutionContext
from .pddl_client import ModelClient
from .main import ContractValidator, ResourceManager
from pathlib import Path
import json
from typing import Dict, Any
import re
import uuid
from .task_repository import TaskRepository


class TaskExecutionManager:
    """Manages execution of tasks and workflows."""
    
    def __init__(self, model_client=None):
        """Initialize with optional model client."""
        if model_client is None:
            self.model_client = ModelClient("codestral:latest")
        else:
            self.model_client = model_client
            
        self.contract_validator = ContractValidator()
        self.resource_manager = ResourceManager()
        
    def prepare_execution_context(self, task: Task, inputs: Dict[str, Any] = None) -> ExecutionContext:
        """Prepare execution context for a task."""
        if inputs is None:
            inputs = {}
            
        context = ExecutionContext(
            task_id=task.id,
            inputs=inputs,
            outputs={},
            errors=[],
            execution_trace=[]
        )
        
        # Validate inputs
        errors = self.contract_validator.validate_task_inputs(task, inputs)
        if errors:
            context.errors.extend(errors)
            
        return context
        
    def execute_task(self, task: Task, context: ExecutionContext) -> Dict[str, Any]:
        """Execute a single task."""
        # Check if context has errors
        if context.errors:
            return {"success": False, "errors": context.errors}
            
        try:
            # Generate code if not already generated
            if task.generated_code is None:
                task.generated_code = self.model_client.generate_code_with_contract(task)
                
            # Create execution sandbox
            result = self._execute_code_in_sandbox(task.generated_code, context.inputs)
            
            # Update context with results
            context.outputs = result.get("outputs", {})
            if "trace" in result:
                context.execution_trace.extend(result["trace"])
            if "errors" in result:
                context.errors.extend(result["errors"])
                
            # Validate outputs
            output_errors = self.contract_validator.validate_task_outputs(task, context.outputs)
            if output_errors:
                context.errors.extend(output_errors)
                
            return {
                "success": not context.errors,
                "outputs": context.outputs,
                "errors": context.errors,
                "trace": context.execution_trace
            }
            
        except Exception as e:
            return {
                "success": False,
                "errors": [f"Execution error: {str(e)}"]}
</file>

<file path="task_repository.py">
from .pddl_classes import Task, TaskStatus
from pathlib import Path
import json
from typing import Dict, List, Optional



class TaskRepository:
    """Storage and management for user-defined tasks."""
    
    def __init__(self, storage_path: str = "user_tasks.json"):
        """Initialize the repository with a storage file path."""
        self.storage_path = Path(storage_path)
        self.tasks: Dict[str, Task] = {}
        self._load_tasks()
        
    def _load_tasks(self) -> None:
        """Load tasks from storage."""
        if not self.storage_path.exists():
            return
            
        try:
            tasks_data = json.loads(self.storage_path.read_text())
            for task_id, task_data in tasks_data.items():
                self.tasks[task_id] = Task(**task_data)
        except Exception as e:
            print(f"Error loading tasks: {e}")
            
    def save_tasks(self) -> None:
        """Save tasks to storage."""
        try:
            tasks_data = {task_id: task.model_dump() for task_id, task in self.tasks.items()}
            self.storage_path.write_text(json.dumps(tasks_data, indent=2))
        except Exception as e:
            print(f"Error saving tasks: {e}")
            
    def add_task(self, task: Task) -> None:
        """Add a task to the repository."""
        self.tasks[task.id] = task
        self.save_tasks()
        
    def update_task(self, task: Task) -> None:
        """Update an existing task."""
        self.tasks[task.id] = task
        self.save_tasks()
        
    def delete_task(self, task_id: str) -> bool:
        """Delete a task from the repository."""
        if task_id in self.tasks:
            del self.tasks[task_id]
            self.save_tasks()
            return True
        return False
        
    def get_task(self, task_id: str) -> Optional[Task]:
        """Get a task by ID."""
        return self.tasks.get(task_id)
        
    def list_tasks(self) -> List[Task]:
        """List all tasks."""
        return list(self.tasks.values())
        
    def search_tasks(self, query: str) -> List[Task]:
        """Search tasks by name or description."""
        query = query.lower()
        return [
            task for task in self.tasks.values()
            if query in task.name.lower() or query in task.description.lower()
        ]
        
    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:
        """Get tasks by status."""
        return [task for task in self.tasks.values() if task.status == status]
</file>

<file path="test_demo.py">
import tempfile
import json
from pathlib import Path

# Updated imports to reflect the new class structure
from app.utils.pddl.main import SecureContractPlanningAPI, PlanRequest, ContractValidator
from app.utils.pddl.pddl_classes import Task, TaskContract, InputContract, OutputContract, DataType
from .pddl_classes import *

def generate_plan_and_code_from_description(description: str, use_solver: bool = False):
    """
    Generates a plan and code using the main SecureContractPlanningAPI and prints all outputs.
    
    Args:
        description: The natural language description of the goal.
        use_solver: Whether to attempt using an external PDDL solver.
    """
    # Initialize the high-level API, which is the correct entry point
    api = SecureContractPlanningAPI()
    
    # Create a request object
    request = PlanRequest(
        description=description,
        use_real_pddl_solver=use_solver
    )
    
    print(f"Parsing and Planning: '{description}' (Solver: {use_solver})")
    
    # The API call handles parsing, planning, and code generation
    response = api.create_plan(request)
    
    # Print the entire response object as a formatted JSON for a complete overview
    print("\n" + "#"*20 + " FULL API RESPONSE " + "#"*20)
    print(response.model_dump_json(indent=2))
    print("#"*59 + "\n")

    print(f" Execution Ready: {response.execution_ready}")
    print(f" Solver Used: {response.solver_used}")

    # Print a detailed breakdown of the response components
    print("\n" + "="*10 + " DETAILED OUTPUTS " + "="*10)

    print("\n Generated Tasks and Detailed Contracts:")
    for task_id, contract in response.contracts.items():
        print(f"\n  --- Task: {task_id} ---")
        print(f"  Inputs: {json.dumps([inp.model_dump() for inp in contract.inputs], indent=4)}")
        print(f"  Outputs: {json.dumps([out.model_dump() for out in contract.outputs], indent=4)}")
        print(f"  Preconditions: {contract.preconditions}")
        print(f"  Postconditions: {contract.postconditions}")
    
    print(f"\n Execution Plan:")
    for i, step in enumerate(response.plan):
        print(f"  {i+1}. {step}")

    print("\n Status Transitions:")
    if response.status_transitions:
        for transition in response.status_transitions:
            print(f"  - {transition}")
    else:
        print("  - No status transitions in plan.")

    print("\n Resource Allocation:")
    for task_id, resources in response.resource_allocation.items():
        print(f"  - {task_id}: {resources}")

    print("\n" + " Contract Validation Results:")
    for task_id, errors in response.validation_results.items():
        if not errors:
            print(f"  - {task_id}:  Validated successfully.")
        else:
            print(f"  - {task_id}:  Validation failed with errors: {errors}")

    print("\n Generated Code:")
    for task_id, code in response.generated_code.items():
        print(f"\n--- Code for {task_id} ---")
        print(code)
        print("--- End of Code ---")
        
    return response

def create_custom_task_with_contract() -> Task:
    """
    Creates a custom task with an explicit contract using valid rules.
    """
    # Define contract with validation rules that exist in the validator
    contract = TaskContract(
        task_id="data_processor",
        inputs=[
            InputContract(
                name="csv_file_path",
                data_type=DataType.FILE,
                required=True,
                # NOTE: File existence is checked by the DataType validator itself, not a rule.
                validation_rules=["ends with .csv"],
                description="Input CSV file to process"
            ),
            InputContract(
                name="filter_config",
                data_type=DataType.JSON,
                required=True,
                # Use valid rules from the new ContractValidator
                validation_rules=["has columns", "has criteria"],
                description="Filtering configuration"
            )
        ],
        outputs=[
            OutputContract(
                name="processed_data",
                data_type=DataType.JSON,
                validation_rules=["not empty"],
                description="Filtered and processed data"
            )
        ],
        preconditions=["CSV file is readable", "Filter config is valid"],
        postconditions=["Data is filtered according to config"]
    )
    
    task = Task(
        id="data_processor",
        name="CSV Data Processor",
        description="Process CSV data with custom filtering",
        duration_hours=2,
        dependencies=[],
        required_resources=["compute", "storage"],
        contract=contract,
        status=TaskStatus.PENDING,
        execution_environment="python"
    )
    
    return task

def demonstrate_contract_validation():
    """
    Shows how to use the ContractValidator independently.
    NOTE: This replaces the old `validate_and_execute_task` function.
    """
    print("\n=== Demonstrating Contract Validation (No Execution) ===")
    validator = ContractValidator()
    task = create_custom_task_with_contract()
    
    # Create a temporary dummy file for the validation to pass
    with tempfile.NamedTemporaryFile(suffix=".csv", delete=True, mode='w') as temp_csv:
        temp_csv.write("header1,header2\nvalue1,value2")
        temp_csv.flush() # Ensure data is written to disk
        
        # --- Test Case 1: Valid Inputs ---
        valid_inputs = {
            "csv_file_path": temp_csv.name, # Use the path of the existing temp file
            "filter_config": {
                "columns": ["name", "age", "city"],
                "criteria": {"age": ">= 18"}
            }
        }
        
        print("\nTesting with VALID inputs...")
        input_errors = validator.validate_task_inputs(task, valid_inputs)
        if not input_errors:
            print(" Input validation passed as expected.")
        else:
            print(f" Input validation failed unexpectedly: {input_errors}")
            
        # --- Test Case 2: Invalid Inputs ---
        invalid_inputs = {
            "csv_file_path": "/non/existent/path.csv", # File does not exist
            "filter_config": {
                "columns": ["name", "age"]
                # Missing 'criteria' key
            }
        }
        
        print("\nTesting with INVALID inputs...")
        invalid_errors = validator.validate_task_inputs(task, invalid_inputs)
        if invalid_errors:
            print(" Input validation failed as expected.")
            for error in invalid_errors:
                print(f"   - {error}")
        else:
            print(" Input validation passed unexpectedly.")

if __name__ == "__main__":
    
    # Pattern 1: Simple description to code using the default topological planner
    print("="*50)
    print("### Pattern 1: Description to Code (Topological Sort Planner) ###")
    print("="*50)
    description_to_code = "Create a REST API endpoint that validates user input and stores data in a database"
    generate_plan_and_code_from_description(description_to_code, use_solver=False)
    
    # Pattern 2: Demonstrating the creation of a custom task object
    print("\n" + "="*50)
    print("### Pattern 2: Custom Task Definition ###")
    print("="*50)
    custom_task = create_custom_task_with_contract()
    print(f"Successfully created task: '{custom_task.name}'")
    print("Full task object details:")
    # Use model_dump_json for a clean, readable representation of the Pydantic object
    print(custom_task.model_dump_json(indent=2))
    
    # Pattern 3: Independent validation demo
    print("\n" + "="*50)
    print("### Pattern 3: Standalone Contract Validation ###")
    print("="*50)
    demonstrate_contract_validation()
</file>

<file path="workflow_builder.py">
from typing import Dict, Any
import uuid
from .task_repository import TaskRepository


class WorkflowBuilder:
    """Build workflows by connecting multiple tasks."""
    
    def __init__(self, task_repository: TaskRepository):
        """Initialize with a task repository."""
        self.task_repository = task_repository
        
    def create_workflow(self, name: str, description: str) -> Dict[str, Any]:
        """Create a new workflow with connected tasks."""
        print(f"=== Creating Workflow: {name} ===")
        print(description)
        
        workflow = {
            "id": f"workflow_{uuid.uuid4().hex[:8]}",
            "name": name,
            "description": description,
            "tasks": {},
            "connections": []
        }
        
        # Show available tasks
        available_tasks = self.task_repository.list_tasks()
        print("\nAvailable tasks:")
        for i, task in enumerate(available_tasks):
            print(f"{i+1}. {task.name} ({task.id})")
            
        # Add tasks to workflow
        workflow_tasks = {}
        while True:
            task_choice = input("\nAdd task to workflow (number or ID, leave empty to finish): ")
            if not task_choice:
                break
                
            try:
                # Handle both number (index) or direct ID input
                if task_choice.isdigit() and int(task_choice) <= len(available_tasks):
                    task = available_tasks[int(task_choice) - 1]
                else:
                    task = self.task_repository.get_task(task_choice)
                    
                if task:
                    # Allow custom task ID in the workflow context
                    workflow_task_id = input(f"Workflow-specific task ID (default: {task.id}): ") or task.id
                    workflow_tasks[workflow_task_id] = task
                    print(f"Added {task.name} as {workflow_task_id}")
                else:
                    print("Task not found")
            except (ValueError, IndexError):
                print("Invalid selection")
                
        # No tasks added
        if not workflow_tasks:
            print("No tasks added to workflow.")
            return workflow
            
        # Create connections between tasks
        print("\n=== Define Task Connections ===")
        print("Available tasks in workflow:")
        for task_id in workflow_tasks:
            print(f"- {task_id}")
            
        while True:
            print("\nAdd connection (format: source_task_id->target_task_id, leave empty to finish):")
            connection = input()
            if not connection:
                break
                
            if "->" in connection:
                source, target = connection.split("->")
                source = source.strip()
                target = target.strip()
                
                if source in workflow_tasks and target in workflow_tasks:
                    workflow["connections"].append({"from": source, "to": target})
                    # Auto-update dependency
                    task_obj = workflow_tasks[target]
                    if source not in task_obj.dependencies:
                        task_obj.dependencies.append(source)
                        self.task_repository.update_task(task_obj)
                    print(f"Connection added: {source} -> {target}")
                else:
                    print("Invalid task IDs")
            else:
                print("Invalid format. Use source->target")
                
        # Store tasks in workflow
        workflow["tasks"] = {tid: task.model_dump() for tid, task in workflow_tasks.items()}
        
        print("\nWorkflow created successfully!")
        return workflow
        
    def visualize_workflow(self, workflow: Dict[str, Any]) -> None:
        """Visualize workflow as ASCII diagram."""
        if not workflow["tasks"]:
            print("Empty workflow")
            return
            
        print(f"\n=== Workflow: {workflow['name']} ===")
        print(workflow["description"])
        print("\nTasks:")
        for task_id, task_data in workflow["tasks"].items():
            print(f"- {task_id}: {task_data['name']}")
            
        print("\nConnections:")
        for conn in workflow["connections"]:
            print(f"  {conn['from']} -> {conn['to']}")
            
        # Basic ASCII visualization
        print("\nWorkflow diagram:")
        print("-" * 40)
        
        # Find roots (tasks with no incoming connections)
        incoming = {task_id: 0 for task_id in workflow["tasks"]}
        for conn in workflow["connections"]:
            incoming[conn["to"]] += 1
            
        roots = [task_id for task_id, count in incoming.items() if count == 0]
        
        # BFS to visualize workflow levels
        visited = set()
        current_level = roots
        level = 0
        
        while current_level:
            print(f"Level {level}:", " | ".join(current_level))
            visited.update(current_level)
            
            next_level = []
            for task_id in current_level:
                # Find outgoing connections
                for conn in workflow["connections"]:
                    if conn["from"] == task_id and conn["to"] not in visited and conn["to"] not in next_level:
                        next_level.append(conn["to"])
                        
            current_level = next_level
            level += 1
            
        # Check for disconnected tasks
        disconnected = set(workflow["tasks"].keys()) - visited
        if disconnected:
            print("Disconnected tasks:", ", ".join(disconnected))
            
        print("-" * 40)
</file>

</files>
